[{"content":"项目提供了一系列的 Makefile 来简化开发流程.\n一般只会用到项目根目录中的 Makefile:\nBOOTLOADER_ELF = ./kernel/bootloader/rustsbi-qemu KERNEL_ELF = ./kernel/target/riscv64gc-unknown-none-elf/release/kernel sbi-qemu: @cp $(BOOTLOADER_ELF) sbi-qemu kernel-qemu: @mv kernel/cargo kernel/.cargo @cd kernel/ \u0026amp;\u0026amp; make kernel @cp $(KERNEL_ELF) kernel-qemu all: sbi-qemu kernel-qemu clean: @rm -f kernel-qemu @rm -f sbi-qemu @rm -rf build/ @rm -rf temp/ @cd kernel/ \u0026amp;\u0026amp; cargo clean @cd workspace/ \u0026amp;\u0026amp; make clean @cd fat32/ \u0026amp;\u0026amp; cargo clean @cd misc/ \u0026amp;\u0026amp; make clean fat32img: @cd kernel/ \u0026amp;\u0026amp; make fat32img run: @cd kernel/ \u0026amp;\u0026amp; make run debug-server: @cd kernel/ \u0026amp;\u0026amp; make debug-server debug: @cd kernel/ \u0026amp;\u0026amp; make debug 这里只需关注以下几点:\nrun: 构建内核并运行，内核是以 release 方式构建的 debug-server: 以 debug 方式构建内核并运行 gdb debug server debug: 链接上面运行的 debug server 开始调试 ","date":"2023-06-30","permalink":"https://bitethedisk.github.io/post/about-makefile/","tags":["Makefile","Debug"],"title":"有关 BTD 的 Makefile"},{"content":"在 BTD 的开发中经常会遇到 debug 的需求，BTD 提供了一个方便的调试流程，只需启动两个 shell 即可 开始调试\n下面将演示一次具体的调试流程\n启动两个 shell，在项目根目录下分别运行 make debug-server 和 make debug， 之后只需要在运行 make debug 的 shell 中执行接下来的命令即可 # 从当前 pc 开始显示 11 条指令，11 条是不发生折叠的极限（也可能只是我这是这样） (gdb) x/11i $pc (gdb) b *0x80000000 # 在内核第一条指令处打个断点 (gdb) c # continue 执行到断点处 (gdb) si # si 单步执行 (step in，会嵌入函数具体流程中) 需要注意的是，在多核运行时，代码执行过程中会出现系统线程的切换，例如下面这样：\n(gdb) c Continuing. [Switching to Thread 1.2] 这时候我们要看当前线程的状态，根据当前状态进行调试，该打断点的地方不要忘了打断点，不然会跑飞\n像是这样，只能用 Ctrl + C 来掐死 (主要是我也没去找其他可能的方法 😛):\n看到地址了吗，直接归零，而且这块地址是不可访问的，只能卡在这了，除非扬了当前的 shell 重来（大概\nThread 2 received signal SIGINT, Interrupt. 0x0000000000000000 in ?? () (gdb) x/11i $pc =\u0026gt; 0x0: Cannot access memory at address 0x0 (gdb) ","date":"2023-06-30","permalink":"https://bitethedisk.github.io/post/how-to-debug-the-kernel/","tags":["OSKernel","Debug"],"title":"开发中如调试内核"},{"content":"内核在运行的时候总是会不知何时卡死，底层原因是持续触发时钟中断\n// 时间片到了 Trap::Interrupt(Interrupt::SupervisorTimer) =\u0026gt; { set_next_trigger(); // 主要是这里 suspend_current_and_run_next(); } 初步解决 我们将设置下一个时钟中断放置在了 suspend_current_and_run_next 之前，导致可能因为后者执行 时间过长而使用户态一直处于时钟中断触发状态，至于为什么会在 RV64 上一直触发中断，可以参阅 RV 的特权级手册:\nPlatforms provide a real-time counter, exposed as a memory-mapped machine-mode read-write register, mtime. mtime must increment at constant frequency, and the platform must provide a mechanism for determining the period of an mtime tick. The mtime register will wrap around if the count overflows.\nThe mtime register has a 64-bit precision on all RV32 and RV64 systems. Platforms provide a 64- bit memory-mapped machine-mode timer compare register (mtimecmp). A machine timer interrupt becomes pending whenever mtime contains a value greater than or equal to mtimecmp, treating the values as unsigned integers. The interrupt remains posted until mtimecmp becomes greater than mtime (typically as a result of writing mtimecmp). The interrupt will only be taken if interrupts are enabled and the MTIE bit is set in the mie register.\n由于 suspend_current_and_run_next 执行的时间超过了一个时间片的长度，导致其返回用户态进程时， mtime 的值已经大于了 set_next_trigger 设置的时间点，由上文可得，如果 mtime 大于等于 mtimecmp(即 set_next_trigger 设置的值)，并且 mie 为使能状态，那么时钟中断会一直处于触发状态.\n而我们的内核 mie 一直处于使能状态，所以 S 态的时钟中断会持续在用户态发生(S 态中断不会打断同级与 更高特权级代码的执行)，导致用户态毫无进展，而我们内核的引导程序 initproc 会一直等待卡死用户进程 变为僵尸态，所以造成了内核执行流的卡死.\n解决办法:\n简单调整下位置\nTrap::Interrupt(Interrupt::SupervisorTimer) =\u0026gt; { suspend_current_and_run_next(); set_next_trigger(); } 但这样真的对吗? 不对，因为会导致用户态程序卡死整个内核的执行流\n一个致命的缺点是，用户态的程序需要第一次运行后才能正确的获取时钟中断，不然只能等轮回一边后才可能正确让出\n当前的逻辑是:\nRustSBI 完成初始化后，在 meow(没错，这是我们 Rust 代码的 ENTRYPOINT)，中初步设定一个时钟中断\n#[cfg(not(feature = \u0026quot;multi_harts\u0026quot;))] #[no_mangle] pub fn meow() -\u0026gt; ! { if hartid!() == 0 { init_bss(); unsafe { set_fs(FS::Dirty) } lang_items::setup(); logging::init(); mm::init(); trap::init(); trap::enable_stimer_interrupt(); trap::set_next_trigger(); fs::init(); task::add_initproc(); task::run_tasks(); } else { loop {} } unreachable!(\u0026quot;main.rs/meow: you should not be here!\u0026quot;); } 这是第一个问题，我们原本想的是，这个时钟中断会在第一用户态程序运行时发生，但是有可能它在 fs::init() 或者 task::add_initproc() 中已经发生了，这会导致一进入用户态程序就发生中断，这和我们 预期的不一样.\n而且，陷入中断后，除非使失能 mie，或者再次 set_next_trigger()(又或者 mtime 发生回环)， 否则将一直处于中断触发的状态\n而这之后切换的用户进程都会遇到中断而直接返回，直到运行到第一个用户进程(其实应该是引导程序 initproc)， 在下面 suspend_current_and_run_next 真正意义上的返回后，重新设置下一个中断时间点，这才能让 OS 内核 所有的用户进程进入正常的运行流.\nTrap::Interrupt(Interrupt::SupervisorTimer) =\u0026gt; { suspend_current_and_run_next(); set_next_trigger(); } 而这种时间上的开销显然是没必要的，所以我们根据所有用户进程都会通过 trap_return 返回用户态这一点， 将 set_next_trigger 设置在了 trap_return 中，同时判断当前进程是否是因为时间片耗尽而导致的 trap 返回:\nTrap::Interrupt(Interrupt::SupervisorTimer) =\u0026gt; { suspend_current_and_run_next(); } // ... #[no_mangle] pub fn trap_return() -\u0026gt; ! { // ... if is_time_intr_trap() { set_next_trigger(); } // ... } /// 是否是由于时间片耗尽导致的 trap fn is_time_intr_trap() -\u0026gt; bool { let scause = scause::read(); scause.cause() == Trap::Interrupt(scause::Interrupt::SupervisorTimer) } 最终结果 我们消除了一个严重的 bug: 内核在执行用户程序时随机卡死 删去了 meow 中不利于系统鲁棒性的代码 ","date":"2023-06-29","permalink":"https://bitethedisk.github.io/post/random-stuck/","tags":["Problems-\u0026-Solutions"],"title":"[已解决]内核在执行用户程序时随机卡死"}]