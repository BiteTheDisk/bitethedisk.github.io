[{"content":"é¡¹ç›®æä¾›äº†ä¸€ç³»åˆ—çš„ Makefile æ¥ç®€åŒ–å¼€å‘æµç¨‹.\nä¸€èˆ¬åªä¼šç”¨åˆ°é¡¹ç›®æ ¹ç›®å½•ä¸­çš„ Makefile:\nBOOTLOADER_ELF = ./kernel/bootloader/rustsbi-qemu KERNEL_ELF = ./kernel/target/riscv64gc-unknown-none-elf/release/kernel sbi-qemu: @cp $(BOOTLOADER_ELF) sbi-qemu kernel-qemu: @mv kernel/cargo kernel/.cargo @cd kernel/ \u0026amp;\u0026amp; make kernel @cp $(KERNEL_ELF) kernel-qemu all: sbi-qemu kernel-qemu clean: @rm -f kernel-qemu @rm -f sbi-qemu @rm -rf build/ @rm -rf temp/ @cd kernel/ \u0026amp;\u0026amp; cargo clean @cd workspace/ \u0026amp;\u0026amp; make clean @cd fat32/ \u0026amp;\u0026amp; cargo clean @cd misc/ \u0026amp;\u0026amp; make clean fat32img: @cd kernel/ \u0026amp;\u0026amp; make fat32img run: @cd kernel/ \u0026amp;\u0026amp; make run debug-server: @cd kernel/ \u0026amp;\u0026amp; make debug-server debug: @cd kernel/ \u0026amp;\u0026amp; make debug è¿™é‡Œåªéœ€å…³æ³¨ä»¥ä¸‹å‡ ç‚¹:\nrun: æ„å»ºå†…æ ¸å¹¶è¿è¡Œï¼Œå†…æ ¸æ˜¯ä»¥ release æ–¹å¼æ„å»ºçš„ debug-server: ä»¥ debug æ–¹å¼æ„å»ºå†…æ ¸å¹¶è¿è¡Œ gdb debug server debug: é“¾æ¥ä¸Šé¢è¿è¡Œçš„ debug server å¼€å§‹è°ƒè¯• ","date":"2023-06-30","permalink":"https://bitethedisk.github.io/post/about-makefile/","tags":["Makefile","Debug"],"title":"æœ‰å…³ BTD çš„ Makefile"},{"content":"åœ¨ BTD çš„å¼€å‘ä¸­ç»å¸¸ä¼šé‡åˆ° debug çš„éœ€æ±‚ï¼ŒBTD æä¾›äº†ä¸€ä¸ªæ–¹ä¾¿çš„è°ƒè¯•æµç¨‹ï¼Œåªéœ€å¯åŠ¨ä¸¤ä¸ª shell å³å¯ å¼€å§‹è°ƒè¯•\nä¸‹é¢å°†æ¼”ç¤ºä¸€æ¬¡å…·ä½“çš„è°ƒè¯•æµç¨‹\nå¯åŠ¨ä¸¤ä¸ª shellï¼Œåœ¨é¡¹ç›®æ ¹ç›®å½•ä¸‹åˆ†åˆ«è¿è¡Œ make debug-server å’Œ make debugï¼Œ ä¹‹ååªéœ€è¦åœ¨è¿è¡Œ make debug çš„ shell ä¸­æ‰§è¡Œæ¥ä¸‹æ¥çš„å‘½ä»¤å³å¯ # ä»å½“å‰ pc å¼€å§‹æ˜¾ç¤º 11 æ¡æŒ‡ä»¤ï¼Œ11 æ¡æ˜¯ä¸å‘ç”ŸæŠ˜å çš„æé™ï¼ˆä¹Ÿå¯èƒ½åªæ˜¯æˆ‘è¿™æ˜¯è¿™æ ·ï¼‰ (gdb) x/11i $pc (gdb) b *0x80000000 # åœ¨å†…æ ¸ç¬¬ä¸€æ¡æŒ‡ä»¤å¤„æ‰“ä¸ªæ–­ç‚¹ (gdb) c # continue æ‰§è¡Œåˆ°æ–­ç‚¹å¤„ (gdb) si # si å•æ­¥æ‰§è¡Œ (step inï¼Œä¼šåµŒå…¥å‡½æ•°å…·ä½“æµç¨‹ä¸­) éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨å¤šæ ¸è¿è¡Œæ—¶ï¼Œä»£ç æ‰§è¡Œè¿‡ç¨‹ä¸­ä¼šå‡ºç°ç³»ç»Ÿçº¿ç¨‹çš„åˆ‡æ¢ï¼Œä¾‹å¦‚ä¸‹é¢è¿™æ ·ï¼š\n(gdb) c Continuing. [Switching to Thread 1.2] è¿™æ—¶å€™æˆ‘ä»¬è¦çœ‹å½“å‰çº¿ç¨‹çš„çŠ¶æ€ï¼Œæ ¹æ®å½“å‰çŠ¶æ€è¿›è¡Œè°ƒè¯•ï¼Œè¯¥æ‰“æ–­ç‚¹çš„åœ°æ–¹ä¸è¦å¿˜äº†æ‰“æ–­ç‚¹ï¼Œä¸ç„¶ä¼šè·‘é£\nåƒæ˜¯è¿™æ ·ï¼Œåªèƒ½ç”¨ Ctrl + C æ¥ææ­» (ä¸»è¦æ˜¯æˆ‘ä¹Ÿæ²¡å»æ‰¾å…¶ä»–å¯èƒ½çš„æ–¹æ³• ğŸ˜›):\nçœ‹åˆ°åœ°å€äº†å—ï¼Œç›´æ¥å½’é›¶ï¼Œè€Œä¸”è¿™å—åœ°å€æ˜¯ä¸å¯è®¿é—®çš„ï¼Œåªèƒ½å¡åœ¨è¿™äº†ï¼Œé™¤éæ‰¬äº†å½“å‰çš„ shell é‡æ¥ï¼ˆå¤§æ¦‚\nThread 2 received signal SIGINT, Interrupt. 0x0000000000000000 in ?? () (gdb) x/11i $pc =\u0026gt; 0x0: Cannot access memory at address 0x0 (gdb) ","date":"2023-06-30","permalink":"https://bitethedisk.github.io/post/how-to-debug-the-kernel/","tags":["OSKernel","Debug"],"title":"å¼€å‘ä¸­å¦‚è°ƒè¯•å†…æ ¸"},{"content":"å†…æ ¸åœ¨è¿è¡Œçš„æ—¶å€™æ€»æ˜¯ä¼šä¸çŸ¥ä½•æ—¶å¡æ­»ï¼Œåº•å±‚åŸå› æ˜¯æŒç»­è§¦å‘æ—¶é’Ÿä¸­æ–­\n// æ—¶é—´ç‰‡åˆ°äº† Trap::Interrupt(Interrupt::SupervisorTimer) =\u0026gt; { set_next_trigger(); // ä¸»è¦æ˜¯è¿™é‡Œ suspend_current_and_run_next(); } åˆæ­¥è§£å†³ æˆ‘ä»¬å°†è®¾ç½®ä¸‹ä¸€ä¸ªæ—¶é’Ÿä¸­æ–­æ”¾ç½®åœ¨äº† suspend_current_and_run_next ä¹‹å‰ï¼Œå¯¼è‡´å¯èƒ½å› ä¸ºåè€…æ‰§è¡Œ æ—¶é—´è¿‡é•¿è€Œä½¿ç”¨æˆ·æ€ä¸€ç›´å¤„äºæ—¶é’Ÿä¸­æ–­è§¦å‘çŠ¶æ€ï¼Œè‡³äºä¸ºä»€ä¹ˆä¼šåœ¨ RV64 ä¸Šä¸€ç›´è§¦å‘ä¸­æ–­ï¼Œå¯ä»¥å‚é˜… RV çš„ç‰¹æƒçº§æ‰‹å†Œ:\nPlatforms provide a real-time counter, exposed as a memory-mapped machine-mode read-write register, mtime. mtime must increment at constant frequency, and the platform must provide a mechanism for determining the period of an mtime tick. The mtime register will wrap around if the count overflows.\nThe mtime register has a 64-bit precision on all RV32 and RV64 systems. Platforms provide a 64- bit memory-mapped machine-mode timer compare register (mtimecmp). A machine timer interrupt becomes pending whenever mtime contains a value greater than or equal to mtimecmp, treating the values as unsigned integers. The interrupt remains posted until mtimecmp becomes greater than mtime (typically as a result of writing mtimecmp). The interrupt will only be taken if interrupts are enabled and the MTIE bit is set in the mie register.\nç”±äº suspend_current_and_run_next æ‰§è¡Œçš„æ—¶é—´è¶…è¿‡äº†ä¸€ä¸ªæ—¶é—´ç‰‡çš„é•¿åº¦ï¼Œå¯¼è‡´å…¶è¿”å›ç”¨æˆ·æ€è¿›ç¨‹æ—¶ï¼Œ mtime çš„å€¼å·²ç»å¤§äºäº† set_next_trigger è®¾ç½®çš„æ—¶é—´ç‚¹ï¼Œç”±ä¸Šæ–‡å¯å¾—ï¼Œå¦‚æœ mtime å¤§äºç­‰äº mtimecmp(å³ set_next_trigger è®¾ç½®çš„å€¼)ï¼Œå¹¶ä¸” mie ä¸ºä½¿èƒ½çŠ¶æ€ï¼Œé‚£ä¹ˆæ—¶é’Ÿä¸­æ–­ä¼šä¸€ç›´å¤„äºè§¦å‘çŠ¶æ€.\nè€Œæˆ‘ä»¬çš„å†…æ ¸ mie ä¸€ç›´å¤„äºä½¿èƒ½çŠ¶æ€ï¼Œæ‰€ä»¥ S æ€çš„æ—¶é’Ÿä¸­æ–­ä¼šæŒç»­åœ¨ç”¨æˆ·æ€å‘ç”Ÿ(S æ€ä¸­æ–­ä¸ä¼šæ‰“æ–­åŒçº§ä¸ æ›´é«˜ç‰¹æƒçº§ä»£ç çš„æ‰§è¡Œ)ï¼Œå¯¼è‡´ç”¨æˆ·æ€æ¯«æ— è¿›å±•ï¼Œè€Œæˆ‘ä»¬å†…æ ¸çš„å¼•å¯¼ç¨‹åº initproc ä¼šä¸€ç›´ç­‰å¾…å¡æ­»ç”¨æˆ·è¿›ç¨‹ å˜ä¸ºåƒµå°¸æ€ï¼Œæ‰€ä»¥é€ æˆäº†å†…æ ¸æ‰§è¡Œæµçš„å¡æ­».\nè§£å†³åŠæ³•:\nç®€å•è°ƒæ•´ä¸‹ä½ç½®\nTrap::Interrupt(Interrupt::SupervisorTimer) =\u0026gt; { suspend_current_and_run_next(); set_next_trigger(); } ä½†è¿™æ ·çœŸçš„å¯¹å—? ä¸å¯¹ï¼Œå› ä¸ºä¼šå¯¼è‡´ç”¨æˆ·æ€ç¨‹åºå¡æ­»æ•´ä¸ªå†…æ ¸çš„æ‰§è¡Œæµ\nä¸€ä¸ªè‡´å‘½çš„ç¼ºç‚¹æ˜¯ï¼Œç”¨æˆ·æ€çš„ç¨‹åºéœ€è¦ç¬¬ä¸€æ¬¡è¿è¡Œåæ‰èƒ½æ­£ç¡®çš„è·å–æ—¶é’Ÿä¸­æ–­ï¼Œä¸ç„¶åªèƒ½ç­‰è½®å›ä¸€è¾¹åæ‰å¯èƒ½æ­£ç¡®è®©å‡º\nå½“å‰çš„é€»è¾‘æ˜¯:\nRustSBI å®Œæˆåˆå§‹åŒ–åï¼Œåœ¨ meow(æ²¡é”™ï¼Œè¿™æ˜¯æˆ‘ä»¬ Rust ä»£ç çš„ ENTRYPOINT)ï¼Œä¸­åˆæ­¥è®¾å®šä¸€ä¸ªæ—¶é’Ÿä¸­æ–­\n#[cfg(not(feature = \u0026quot;multi_harts\u0026quot;))] #[no_mangle] pub fn meow() -\u0026gt; ! { if hartid!() == 0 { init_bss(); unsafe { set_fs(FS::Dirty) } lang_items::setup(); logging::init(); mm::init(); trap::init(); trap::enable_stimer_interrupt(); trap::set_next_trigger(); fs::init(); task::add_initproc(); task::run_tasks(); } else { loop {} } unreachable!(\u0026quot;main.rs/meow: you should not be here!\u0026quot;); } è¿™æ˜¯ç¬¬ä¸€ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬åŸæœ¬æƒ³çš„æ˜¯ï¼Œè¿™ä¸ªæ—¶é’Ÿä¸­æ–­ä¼šåœ¨ç¬¬ä¸€ç”¨æˆ·æ€ç¨‹åºè¿è¡Œæ—¶å‘ç”Ÿï¼Œä½†æ˜¯æœ‰å¯èƒ½å®ƒåœ¨ fs::init() æˆ–è€… task::add_initproc() ä¸­å·²ç»å‘ç”Ÿäº†ï¼Œè¿™ä¼šå¯¼è‡´ä¸€è¿›å…¥ç”¨æˆ·æ€ç¨‹åºå°±å‘ç”Ÿä¸­æ–­ï¼Œè¿™å’Œæˆ‘ä»¬ é¢„æœŸçš„ä¸ä¸€æ ·.\nè€Œä¸”ï¼Œé™·å…¥ä¸­æ–­åï¼Œé™¤éä½¿å¤±èƒ½ mieï¼Œæˆ–è€…å†æ¬¡ set_next_trigger()(åˆæˆ–è€… mtime å‘ç”Ÿå›ç¯)ï¼Œ å¦åˆ™å°†ä¸€ç›´å¤„äºä¸­æ–­è§¦å‘çš„çŠ¶æ€\nè€Œè¿™ä¹‹ååˆ‡æ¢çš„ç”¨æˆ·è¿›ç¨‹éƒ½ä¼šé‡åˆ°ä¸­æ–­è€Œç›´æ¥è¿”å›ï¼Œç›´åˆ°è¿è¡Œåˆ°ç¬¬ä¸€ä¸ªç”¨æˆ·è¿›ç¨‹(å…¶å®åº”è¯¥æ˜¯å¼•å¯¼ç¨‹åº initproc)ï¼Œ åœ¨ä¸‹é¢ suspend_current_and_run_next çœŸæ­£æ„ä¹‰ä¸Šçš„è¿”å›åï¼Œé‡æ–°è®¾ç½®ä¸‹ä¸€ä¸ªä¸­æ–­æ—¶é—´ç‚¹ï¼Œè¿™æ‰èƒ½è®© OS å†…æ ¸ æ‰€æœ‰çš„ç”¨æˆ·è¿›ç¨‹è¿›å…¥æ­£å¸¸çš„è¿è¡Œæµ.\nTrap::Interrupt(Interrupt::SupervisorTimer) =\u0026gt; { suspend_current_and_run_next(); set_next_trigger(); } è€Œè¿™ç§æ—¶é—´ä¸Šçš„å¼€é”€æ˜¾ç„¶æ˜¯æ²¡å¿…è¦çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬æ ¹æ®æ‰€æœ‰ç”¨æˆ·è¿›ç¨‹éƒ½ä¼šé€šè¿‡ trap_return è¿”å›ç”¨æˆ·æ€è¿™ä¸€ç‚¹ï¼Œ å°† set_next_trigger è®¾ç½®åœ¨äº† trap_return ä¸­ï¼ŒåŒæ—¶åˆ¤æ–­å½“å‰è¿›ç¨‹æ˜¯å¦æ˜¯å› ä¸ºæ—¶é—´ç‰‡è€—å°½è€Œå¯¼è‡´çš„ trap è¿”å›:\nTrap::Interrupt(Interrupt::SupervisorTimer) =\u0026gt; { suspend_current_and_run_next(); } // ... #[no_mangle] pub fn trap_return() -\u0026gt; ! { // ... if is_time_intr_trap() { set_next_trigger(); } // ... } /// æ˜¯å¦æ˜¯ç”±äºæ—¶é—´ç‰‡è€—å°½å¯¼è‡´çš„ trap fn is_time_intr_trap() -\u0026gt; bool { let scause = scause::read(); scause.cause() == Trap::Interrupt(scause::Interrupt::SupervisorTimer) } æœ€ç»ˆç»“æœ æˆ‘ä»¬æ¶ˆé™¤äº†ä¸€ä¸ªä¸¥é‡çš„ bug: å†…æ ¸åœ¨æ‰§è¡Œç”¨æˆ·ç¨‹åºæ—¶éšæœºå¡æ­» åˆ å»äº† meow ä¸­ä¸åˆ©äºç³»ç»Ÿé²æ£’æ€§çš„ä»£ç  ","date":"2023-06-29","permalink":"https://bitethedisk.github.io/post/random-stuck/","tags":["Problems-\u0026-Solutions"],"title":"[å·²è§£å†³]å†…æ ¸åœ¨æ‰§è¡Œç”¨æˆ·ç¨‹åºæ—¶éšæœºå¡æ­»"}]