[{"content":"","date":"2023-08-01","permalink":"https://bitethedisk.github.io/post/rust-and-c/","tags":["å…¨å›½èµ›ç¬¬ä¸€é˜¶æ®µ","FFI"],"title":"Rust å’Œ C çš„äº¤äº’"},{"content":"åœ¨ç›®å‰çš„å®ç°ä¸­ä¿¡å·æ€»å…±æœ‰63ç§ï¼Œ1-31ä¸ºéå®æ—¶ä¿¡å·ï¼Œ34-63æ˜¯å®æ—¶ä¿¡å·ã€‚32å’Œ33ä¸ºæœªå®šä¹‰ä¿¡å·ã€‚ ä¿¡å·æ˜¯æ¯ä¸ªè¿›ç¨‹ç‹¬æœ‰çš„ï¼Œé™¤æ­¤ä¹‹å¤–æ¯ä¸ªè¿›ç¨‹è¿˜æœ‰ä¿¡å·æ©ç ã€‚ æ¶‰åŠä¿¡å·å¤„ç†çš„å…±æœ‰3ä¸ªç³»ç»Ÿè°ƒç”¨ï¼šSYS_SIGACTIONï¼ŒSYS_SIGPROCMASKï¼ŒSYS_SIGRETURNã€‚\næ¶‰åŠçš„ç³»ç»Ÿè°ƒç”¨ sys_sigactionç”¨äºä¸ºä¸€ä¸ªä¿¡å·æ³¨å†Œä¿¡å·å¤„ç†å‡½æ•°ï¼Œå½“è¿›ç¨‹æ¥å—åˆ°ä¿¡å·åä¼šè·³è½¬åˆ°è¿™ä¸ªä¿¡å·å¤„ç†å‡½æ•°ã€‚ä¸€èˆ¬ä¿¡å·å¤„ç†å‡½æ•°åä¼šè°ƒç”¨sigreturnå°†ç¨‹åºä¸Šä¸‹æ–‡æ¢å¤åˆ°æ‰§è¡Œä¿¡å·å¤„ç†å‡½æ•°ä¹‹å‰çš„çŠ¶æ€ã€‚ä½†ç¨‹åºä¹Ÿå¯èƒ½ä¸è°ƒç”¨sigreturnï¼Œè€Œæ˜¯ä½¿ç”¨longjumpè·³è½¬åˆ°åˆ«çš„ä½ç½®ï¼Œå†…æ ¸ä¸å…³å¿ƒä¿¡å·å¤„ç†å‡½æ•°æ˜¯å¦è¿”å›ï¼Œä¸åœ¨å†…æ ¸ä¸­ç»´æŠ¤ä¿¡å·å¤„ç†ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œè€Œæ˜¯åœ¨æ‰§è¡Œä¿¡å·å¤„ç†å‡½æ•°ä¹‹å‰å°†ä¸Šä¸‹æ–‡å‹å…¥ç”¨æˆ·æ ˆï¼Œå¹¶åœ¨sigreturnæ—¶ä»ç”¨æˆ·æ ˆä¸­æ¢å¤ä¿¡æ¯ã€‚åœ¨æ‰§è¡Œä¿¡å·å¤„ç†å‡½æ•°çš„è¿‡ç¨‹ä¸­ï¼Œè¿™äº›ä¿å­˜çš„ä¸Šä¸‹æ–‡ä¿¡æ¯å¯èƒ½è¢«ç”¨æˆ·ç¨‹åºä¿®æ”¹ï¼Œç”¨æˆ·ç¨‹åºå¯ä»¥å€Ÿæ­¤è¿”å›åˆ°ä¸åŒçš„åœ°æ–¹ã€‚\nsys_sigprocmaskç”¨äºä¿®æ”¹è¿›ç¨‹çš„ä¿¡å·æ©ç ã€‚ä¿¡å·æ©ç å¯ä»¥ç”¨æ¥å±è”½ä¿¡å·ï¼Œè¢«å±è”½çš„ä¿¡å·ä¼šè¢«é˜»å¡ï¼Œç›´åˆ°ä¿¡å·æ©ç ä¸å†é˜»å¡è¯¥ä¿¡å·æ—¶è¯¥ä¿¡å·æ‰ä¼šè¢«å¤„ç†ã€‚ 9å·ä¿¡å·å’Œ19å·ä¿¡å·ä¸èƒ½è¢«é˜»å¡ã€‚ sys_sigreturnä¼šä»ç”¨æˆ·æ ˆä¸­å–å‡ºä¸Šä¸‹æ–‡ä¿¡æ¯å°†ç¨‹åºæ¢å¤åˆ°ä¿¡å·å¤„ç†å‰çš„çŠ¶æ€ã€‚ sys_sigreturnæ²¡æœ‰è¿”å›å€¼ï¼Œåœ¨æ‰§è¡Œå®Œåä¸åº”å°†æ‰§è¡Œç»“æœå†™å…¥a0å¯„å­˜å™¨ã€‚\nç”±äºæ‰§è¡Œä¿¡å·å¤„ç†å‡½æ•°æ—¶ä¸æ‰§è¡Œå…¶ä»–ç”¨æˆ·å‡½æ•°æ²¡æœ‰åŒºåˆ«ï¼Œlinuxçš„ä¿¡å·è®¾è®¡è‡ªç„¶æ”¯æŒä¿¡å·å¤„ç†çš„åµŒå¥—ï¼Œåªè¦æ­£ç¡®å®ç°äº†è¿™å‡ ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œæ— éœ€åœ¨å†…æ ¸å†…ä¿å­˜é¢å¤–ä¿¡æ¯å°±å¯ä»¥æ”¯æŒä¿¡å·çš„åµŒå¥—è°ƒç”¨ã€‚ ä¸€èˆ¬ä¿¡å·çš„äº§ç”Ÿæ˜¯é€šè¿‡sys_killç­‰ç³»ç»Ÿè°ƒç”¨äº§ç”Ÿçš„ï¼Œé™¤æ­¤ä¹‹å¤–è¿›ç¨‹é€€å‡ºæ—¶ä¹Ÿä¼šäº§ç”Ÿä¿¡å·ã€‚ ä¿¡å·å¤„ç†çš„æ—¶æœºæ˜¯ä¸ç¡®å®šçš„ã€‚ç°åœ¨å†…æ ¸ä¸­ä¼šåœ¨æ¯æ¬¡è¿”å›ç”¨æˆ·æ€ä¹‹å‰æ£€æŸ¥æœ‰æ— éœ€è¦å¤„ç†çš„ä¿¡å·ã€‚\nä¸å…¶ä»–ç³»ç»Ÿè°ƒç”¨çš„äº¤äº’ sys_wait4 ã€sys_readã€sys_futexç­‰å…·æœ‰é˜»å¡ç­‰å¾…è¡Œä¸ºçš„ç³»ç»Ÿè°ƒç”¨å¯ä»¥è¢«ä¿¡å·ä¸­æ–­ï¼Œå¦‚æœåœ¨é˜»å¡è¿‡ç¨‹ä¸­æœ‰åˆ°æ¥çš„ä¿¡å·åº”è¯¥åœæ­¢ç­‰å¾…ï¼Œè¿”å›è¢«ä¸­æ–­çš„é”™è¯¯ç ã€‚ fork å‡ºæ¥çš„å­è¿›ç¨‹åº”è¯¥ç»§æ‰¿çˆ¶è¿›ç¨‹çš„æ³¨å†Œçš„ä¿¡å·å¤„ç†ç¨‹åºï¼Œå’Œä¿¡å·æ©ç ã€‚ exec åç¨‹åºåº”è¯¥æ¸…ç©ºä¿¡å·å¤„ç†ç¨‹åºä½†æ˜¯ä¿ç•™ä¿¡å·æ©ç ã€‚\n","date":"2023-08-01","permalink":"https://bitethedisk.github.io/post/signal/","tags":["å…¨å›½èµ›ç¬¬ä¸€é˜¶æ®µ"],"title":"ä¿¡å·å¤„ç†"},{"content":"ç”±äºå¤§éƒ¨åˆ†æµ‹è¯•éœ€è¦ä½¿ç”¨ busyboxï¼Œä¸ºäº†é¿å…å¤šæ¬¡è§£æ elfã€ä»é›¶åˆ›å»ºåœ°å€ç©ºé—´ç­‰é—®é¢˜ï¼Œæˆ‘ä»¬é‡‡ç”¨äº†ç±»ä¼¼äºåŠ è½½initprocçš„æ–¹æ³•ã€‚å…·ä½“è€Œè¨€ï¼Œæˆ‘ä»¬å°† busybox é¢„åŠ è½½åˆ°å†…æ ¸ä¸­ï¼Œå¹¶ä¿å­˜ load_elf è·å–çš„ä¿¡æ¯ã€‚æ¯æ¬¡æ‰§è¡Œbusyboxæ—¶ï¼Œæˆ‘ä»¬ç›´æ¥ä½¿ç”¨ä¿å­˜çš„ load_elf ä¿¡æ¯ï¼Œå¹¶é€šè¿‡å†™æ—¶æ‹·è´æ¥åˆ›å»ºæ‰€éœ€çš„ busybox è¿›ç¨‹çš„åœ°å€ç©ºé—´ï¼Œæ›´å¿«é€Ÿåœ°åˆ›å»º busybox è¿›ç¨‹ä»è€Œå®ç°æ›´é«˜æ•ˆçš„æµ‹è¯•ã€‚\n// kernel/src/task/initproc/mod.rs pub static ref BUSYBOX: RwLock\u0026lt;Busybox\u0026gt; = RwLock::new({ extern \u0026quot;C\u0026quot; { fn busybox_entry(); fn busybox_tail(); } let entry = busybox_entry as usize; let tail = busybox_tail as usize; let siz = tail - entry; let busybox = unsafe { core::slice::from_raw_parts(entry as *const u8, siz) }; let path = AbsolutePath::from_str(\u0026quot;/busybox0\u0026quot;); let inode = fs::open(path, OpenFlags::O_CREATE, CreateMode::empty()).expect(\u0026quot;busybox0 create failed\u0026quot;); inode.write_all(\u0026amp;busybox.to_owned()); let bb = Arc::new(TaskControlBlock::new(inode.clone())); inode.delete(); Busybox { inner: bb, } }); pub static mut ONCE_BB_ENTRY: usize = 0; pub static mut ONCE_BB_AUX: Vec\u0026lt;AuxEntry\u0026gt; = Vec::new(); pub struct Busybox { inner: Arc\u0026lt;TaskControlBlock\u0026gt;, } impl Busybox { pub fn elf_entry_point(\u0026amp;self) -\u0026gt; usize { unsafe { ONCE_BB_ENTRY } } pub fn aux(\u0026amp;self) -\u0026gt; Vec\u0026lt;AuxEntry\u0026gt; { unsafe { ONCE_BB_AUX.clone() } } pub fn memory_set(\u0026amp;self) -\u0026gt; MemorySet { let mut write = self.inner.memory_set.write(); MemorySet::from_copy_on_write(\u0026amp;mut write) } } ","date":"2023-08-01","permalink":"https://bitethedisk.github.io/post/busybox-pre-init/","tags":["busybox","å…¨å›½èµ›I"],"title":"[å…¨å›½èµ›I] busybox é¢„åŠ è½½"},{"content":"åœ¨æˆ‘ä»¬çš„å†…æ ¸ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ TASKMANAGER ç®¡ç†åˆ†åˆ«å¤„äºå°±ç»ªæ€ï¼Œé˜»å¡æ€çš„è¿›ç¨‹ï¼ŒåŒ…æ‹¬å› ä¸ºè°ƒç”¨ nanosleep è€Œä¼‘çœ çš„è¿›ç¨‹ã€‚\n// kernel/src/task/manager.rs // è´Ÿè´£ç®¡ç†å¾…è°ƒåº¦çš„è¿›ç¨‹å¯¹è±¡ pub struct TaskManager { ready_queue: VecDeque\u0026lt;Arc\u0026lt;TaskControlBlock\u0026gt;\u0026gt;, waiting_queue: VecDeque\u0026lt;Arc\u0026lt;TaskControlBlock\u0026gt;\u0026gt;, hq: BinaryHeap\u0026lt;HangingTask\u0026gt;, } // ç”¨äºç®¡ç† sleep è¿›ç¨‹ pub struct HangingTask { wake_up_time: usize, // ns inner: Arc\u0026lt;TaskControlBlock\u0026gt;, } // ç”¨äºå¤„ç†å­çº¿ç¨‹çš„èµ„æºå›æ”¶ pub struct ChildrenThreadMonitor { cancelled_child_threads: Vec\u0026lt;Arc\u0026lt;TaskControlBlock\u0026gt;\u0026gt;, } // ç»´æŠ¤å†…æ ¸ä¸­ pid åˆ° TCB çš„æ˜ å°„ pub static ref PID2TCB: Mutex\u0026lt;BTreeMap\u0026lt;usize, Arc\u0026lt;TaskControlBlock\u0026gt;\u0026gt;\u0026gt; = Mutex::new(BTreeMap::new()); // å­çº¿ç¨‹å›æ”¶ç®¡ç†å™¨ pub static CHILDREN_THREAD_MONITOR: Mutex\u0026lt;ChildrenThreadMonitor\u0026gt; = Mutex::new(ChildrenThreadMonitor::new()); // kernel/src/task/processor/processor.rs /// [`Processor`] æ˜¯æè¿° CPUæ‰§è¡ŒçŠ¶æ€ çš„æ•°æ®ç»“æ„ã€‚ /// åœ¨å•æ ¸ç¯å¢ƒä¸‹ï¼Œæˆ‘ä»¬ä»…åˆ›å»ºå•ä¸ª Processor çš„å…¨å±€å®ä¾‹ PROCESSOR pub static mut PROCESSOR: SyncRefCell\u0026lt;Processor\u0026gt; = SyncRefCell::new(Processor::new()); /// æ¯ä¸ªæ ¸ä¸Šçš„å¤„ç†å™¨ï¼Œè´Ÿè´£è¿è¡Œä¸€ä¸ªè¿›ç¨‹ pub struct Processor { /// å½“å‰å¤„ç†å™¨ä¸Šæ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡ current: Option\u0026lt;Arc\u0026lt;TaskControlBlock\u0026gt;\u0026gt;, /// å½“å‰å¤„ç†å™¨ä¸Šçš„ idle æ§åˆ¶æµçš„ä»»åŠ¡ä¸Šä¸‹æ–‡ idle_task_cx: TaskContext, } run_tasks åˆ†åˆ«å°è¯•ä» hang_task, ready_task é˜Ÿåˆ—ä¸­è·å–è¿›ç¨‹è°ƒåº¦ã€‚\n// kernel/src/task/processor/schedule.rs /// è¿›å…¥ idle æ§åˆ¶æµï¼Œå®ƒè¿è¡Œåœ¨è¿™ä¸ª CPU æ ¸çš„å¯åŠ¨æ ˆä¸Šï¼Œ /// åŠŸèƒ½æ˜¯å¾ªç¯è°ƒç”¨ fetch_task ç›´åˆ°é¡ºåˆ©ä»ä»»åŠ¡ç®¡ç†å™¨ä¸­å–å‡ºä¸€ä¸ªä»»åŠ¡ï¼Œéšåä¾¿å‡†å¤‡é€šè¿‡ä»»åŠ¡åˆ‡æ¢çš„æ–¹å¼æ¥æ‰§è¡Œ pub fn run_tasks() { let bb = BUSYBOX.read(); // lazy static busybox drop(bb); loop { let processor = acquire_processor(); recycle_child_threads_res(); if let Some(hanging_task) = check_hanging() { run_task(hanging_task, processor); } else if let Some(interupt_task) = check_futex_interupt_or_expire() { unblock_task(interupt_task); } else if let Some(task) = fetch_task() { run_task(task, processor); } } } å€¼å¾—ä¸€æçš„æ˜¯ï¼Œæˆ‘ä»¬åœ¨è¿›ç¨‹è°ƒåº¦æ—¶è¿˜éœ€è¦æ£€æµ‹ block_task é˜Ÿåˆ—ä¸­ï¼Œå› ä¸ºåœ¨ç³»ç»Ÿè°ƒç”¨è¿‡ç¨‹ä¸­è¢«ä¿¡å·æ‰“æ–­çš„ task æ˜¯å¦æœ‰å¤„ç†å®Œä¿¡å·ï¼Œæˆ–è€… futex_wait æ—¶ç»™å‡ºçš„ timeout æ˜¯å¦å·²è¶…æ—¶ä»¥å”¤é†’è¯¥è¿›ç¨‹å¹¶åŠ å…¥åˆ° ready_task ä¸­ã€‚\n// kernel/src/task/manager.rs pub fn check_futex_interupt_or_expire(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Arc\u0026lt;TaskControlBlock\u0026gt;\u0026gt; { for tcb in self.waiting_queue.iter() { let lock = tcb.inner_ref(); // è¢«ä¿¡å·æ‰“æ–­çš„ task æ˜¯å¦æœ‰å¤„ç†å®Œä¿¡å· if !lock.pending_signals.difference(lock.sigmask).is_empty() { return Some(tcb.clone()); } } let mut global_futex_que = FUTEX_QUEUE.write(); for (_, futex_queue) in global_futex_que.iter_mut() { // timeout æ˜¯å¦å·²è¶…æ—¶ if let Some(task) = futex_queue.pop_expire_waiter() { return Some(task.clone()); } } None } ","date":"2023-08-01","permalink":"https://bitethedisk.github.io/post/scheduling/","tags":["process","thread","å…¨å›½èµ›I"],"title":"[å…¨å›½èµ›I] è¿›ç¨‹/çº¿ç¨‹è°ƒåº¦"},{"content":"TCB ä¸ fork çš„æ›´æ”¹ ç›¸è¾ƒäºåˆèµ›ï¼Œå®Œå–„äº† clone ç³»ç»Ÿè°ƒç”¨ã€‚åˆèµ›æ—¶ç”±äºè¦æ±‚æµ‹è¯•æ ·ä¾‹è¦æ±‚æ¯”è¾ƒä½ï¼Œåœ¨å®ç° clone ç³»ç»Ÿè°ƒç”¨æ—¶å¹¶æœªå®Œå…¨åˆ©ç”¨ç”¨æˆ·ä¼ é€’çš„å‚æ•°ã€‚æˆ‘ä»¬æ ¹æ® Linux manual page ä¸­çš„è¦æ±‚ï¼Œå®Œå–„äº†å†…æ ¸çš„ fork ä»¥åŠ TaskControlBlock ç»“æ„ã€‚\n// kernel/task/task.rs pub struct TaskControlBlock { ... pub sigactions: Arc\u0026lt;RwLock\u0026lt;[SigAction; MAX_SIGNUM as usize]\u0026gt;\u0026gt;, pub memory_set: Arc\u0026lt;RwLock\u0026lt;MemorySet\u0026gt;\u0026gt;, pub fd_table: Arc\u0026lt;RwLock\u0026lt;FDTable\u0026gt;\u0026gt;, pub robust_list: Arc\u0026lt;RwLock\u0026lt;RobustList\u0026gt;\u0026gt;, pub rlimit_nofile: Arc\u0026lt;RwLock\u0026lt;RLimit\u0026gt;\u0026gt;, inner: RwLock\u0026lt;TaskControlBlockInner\u0026gt;, } pub struct TaskControlBlockInner { ... pub pending_signals: SigSet, pub sigmask: SigMask, pub interval_timer: Option\u0026lt;IntervalTimer\u0026gt;, pub utime: TimeVal, pub stime: TimeVal, pub last_enter_umode_time: TimeVal, pub last_enter_smode_time: TimeVal, pub clear_child_tid: usize, /* CLONE_CHILD_CLEARTID */ } ç›¸è¾ƒäºåˆèµ›ï¼Œæˆ‘ä»¬ä¸º TCB åŠ å…¥äº†æœ‰å…³ä¿¡å·ã€æ—¶é—´ã€èµ„æºç­‰ç»“æ„ã€‚å¹¶æ ¹æ® sys_clone ä¼ é€’çš„å‚æ•°ï¼Œæ­£ç¡®åœ°å®ç° forkï¼Œæ¯”å¦‚ä»¥ä¸‹ä»£ç æ®µï¼š\n// kernel/src/task/task.rs(fn fork) // æ‹·è´ç”¨æˆ·åœ°å€ç©ºé—´ let memory_set = if flags.contains(CloneFlags::VM) { self.memory_set.clone() } else { Arc::new(RwLock::new(MemorySet::from_copy_on_write( \u0026amp;mut self.memory_set.write(), ))) }; if flags.contains(CloneFlags::THREAD) { memory_set.write().map_thread_trap_context(private_tid); } // kernel/syscall/impls/process.rs (sys_do_fork) if flags.contains(CloneFlags::PARENT_SETTID) { *translated_mut(current_user_token(), ptid as *mut u32) = new_pid as u32; } if flags.contains(CloneFlags::CHILD_SETTID) { *translated_mut(child_token, ctid as *mut u32) = new_pid as u32; } if flags.contains(CloneFlags::CHILD_CLEARTID) { new_task.inner_mut().clear_child_tid = ctid; } if flags.contains(CloneFlags::SETTLS) { let trap_cx = new_task.inner_mut().trap_context(); trap_cx.set_tp(tls); } çº¿ç¨‹çš„å¼•å…¥ åœ¨ fork è¿‡ç¨‹ä¸­ï¼Œå½“ CloneFlags ä¸­å­˜åœ¨ CLONE_THREAD ä½æ—¶ï¼Œæ­£åœ¨åˆ›å»ºçš„è¿›ç¨‹å½“å‰è¿›ç¨‹çš„ä¸ºå­çº¿ç¨‹\nPid åˆ†é…å™¨çš„æ›´æ”¹\nç”±äºæˆ‘ä»¬çš„å†…æ ¸åœ¨å®ç°çº¿ç¨‹æ—¶ï¼Œä¸ºäº†æ›´æ–¹ä¾¿åœ°ä¸ºå­çº¿ç¨‹åˆ†é… TrapContext Frame èµ„æºï¼Œæˆ‘ä»¬è§„å®šå­çº¿ç¨‹çš„ tid (pid) ä¸åº”è¯¥ä¸å°äºè¿›ç¨‹ï¼ˆä¸»çº¿ç¨‹ï¼‰çš„ tid (pid) ï¼Œæ•…ç§»é™¤äº†è¿›ç¨‹ pid çš„å›æ”¶æ“ä½œã€‚\nå­è¿›ç¨‹ä¸å­çº¿ç¨‹çš„åŒºåˆ†\nç›®å‰æˆ‘ä»¬å°†å­çº¿ç¨‹ä¸å­è¿›ç¨‹å‡ä¿å­˜åœ¨ TCB çš„ children å­—æ®µï¼Œåœ¨é‡åˆ°è¿›ç¨‹é€€å‡ºç­‰é—®é¢˜æ—¶ä¼šåˆ¤æ–­ child æ˜¯å­è¿›ç¨‹è¿˜æ˜¯å­çº¿ç¨‹ã€‚\nç›®å‰é€šè¿‡ tgid ä¸ pid æ¥åŒºåˆ† TCB æ˜¯çˆ¶è¿›ç¨‹çš„å­è¿›ç¨‹è¿˜æ˜¯å­çº¿ç¨‹\n// kernel/src/task/task.rs(fn fork) let pid_handle = pid_alloc(); let tgid = if flags.contains(CloneFlags::THREAD) { self.pid.0 } else { pid_handle.0 }; å¦‚æœ tgid ä¸ pid å€¼ç›¸åŒï¼Œåˆ™è¯¥ TCB ä¸ºè¿›ç¨‹ï¼Œå¦åˆ™ä¸ºçº¿ç¨‹\nä¸ºçº¿ç¨‹åˆ†é…èµ„æº\nçº¿ç¨‹é™¤äº†å…±äº«ä¸»çº¿ç¨‹ï¼ˆè¿›ç¨‹ï¼‰çš„ memory_set, fd_table, sigaction ç­‰èµ„æºï¼Œè¿˜éœ€è¦ä¸€äº›ç‹¬ç«‹çš„èµ„æºå¦‚ID, å†…æ ¸åœ°å€ç©ºé—´çš„KernelStackï¼Œä»¥åŠä¸»çº¿ç¨‹ä¸­ç‹¬ç«‹åˆ†é…çš„ TrapContext Frame:\n// kernel/syscall/impls/process.rs (sys_do_fork) if flags.contains(CloneFlags::THREAD) { memory_set.write().map_thread_trap_context(private_tid); } // kernel/src/task/ttask.rs pub fn trap_context_position(tid: usize) -\u0026gt; VirtAddr { VirtAddr::from(TRAP_CONTEXT - tid * PAGE_SIZE) } å…¶ä¸­ï¼Œprivate_tid ä¸ºtgid(ä¸»çº¿ç¨‹/çˆ¶è¿›ç¨‹)ä¸pid(å­çº¿ç¨‹tid)çš„å·®å€¼\nè¿›ç¨‹/çº¿ç¨‹çš„é€€å‡º å½“å‰è¿›ç¨‹ç»“æŸçš„æ–¹å¼åŒ…æ‹¬ï¼š\nè¿›ç¨‹è¿è¡Œå®Œä»£ç æ®µï¼Œéæ³•è®¿é—®åˆ° .rodata å¼•å‘ trapï¼Œåœ¨ trap å¤„ç†ä¸­å›æ”¶è¿›ç¨‹å¯¹è±¡ è¿›ç¨‹è°ƒç”¨ exit ç³»ç»Ÿè°ƒç”¨ è¿›ç¨‹æ”¶åˆ° kill ç›¸å…³çš„ä¿¡å·ï¼Œåœ¨ä¿¡å·å¤„ç†æ—¶é€€å‡º å…³äºè¿›ç¨‹/çº¿ç¨‹çš„é€€å‡ºæ—¶éœ€è¦åšçš„å·¥ä½œåŒ…æ‹¬ï¼š\nå®Œæˆè¿›ç¨‹çš„åˆæ­¥å›æ”¶ï¼š å°†è‡ªèº«ä» PID2TCB æ˜ å°„ç®¡ç†å™¨ä¸­ç§»é™¤ æ ‡è®°è‡ªèº«çŠ¶æ€ä¸º Zombieï¼Œè®°å½•é€€å‡ºç  å°†å­è¿›ç¨‹ç§»äº¤ç»™ initproc å¦‚æœè‡ªèº«ä¸ºæŸè¿›ç¨‹çš„å­çº¿ç¨‹ï¼Œè¿˜éœ€è¦æ‰¾åˆ°ä¸»è¿›ç¨‹å¹¶å°†è‡ªèº«ä»ä¸»è¿›ç¨‹ä¸­ç§»é™¤ï¼Œå¹¶å‹å…¥å­çº¿ç¨‹å›æ”¶ç®¡ç†å™¨ CHILDREN_THREAD_MONITOR ä¸­ï¼Œåœ¨ä¸‹ä¸€æ¬¡è¿›ç¨‹è°ƒåº¦æ—¶å›æ”¶å¯å›æ”¶çš„èµ„æº è¿›ç¨‹çš„çˆ¶è¿›ç¨‹ç­‰å¾…å­è¿›ç¨‹é€€å‡ºï¼Œè°ƒç”¨ wait ç³»ç»Ÿè°ƒç”¨ï¼Œå®Œæˆå­è¿›ç¨‹èµ„æºçš„å›æ”¶ï¼šæ‰¾åˆ°å­è¿›ç¨‹ä¸­å¤„äº Zombie æ€çš„è¿›ç¨‹å¹¶ä¸”å¼ºå¼•ç”¨è®¡æ•°ä¸º 1 çš„è¿›ç¨‹ï¼Œç§»é™¤è¯¥è¿›ç¨‹ä»¥å½»åº•å›æ”¶è¯¥è¿›ç¨‹çš„æ‰€æœ‰èµ„æº å­çº¿ç¨‹èµ„æºå›æ”¶\nå­çº¿ç¨‹é€€å‡ºæ—¶ï¼Œå­çº¿ç¨‹ä¼šåŠ å…¥åˆ°å›æ”¶ç®¡ç†å™¨ CHILDREN_THREAD_MONITOR ä¸­ï¼Œå¹¶åœ¨ä¸‹ä¸€æ¬¡è¿›ç¨‹è°ƒåº¦æ—¶å›æ”¶å¯å›æ”¶çš„èµ„æºã€‚\n// kernel/src/task/mod.rs (fn exit_current_and_run_next) if is_child_thread { let parent = inner.parent.as_ref().unwrap().upgrade().unwrap(); let mut parent_inner = parent.inner_mut(); let children_iter = parent_inner.children.iter(); let (idx, _) = children_iter .enumerate() .find(|(_, t)| t.pid() == pid) .unwrap(); parent_inner.children.remove(idx); drop(parent_inner); drop(parent); drop(inner); assert!(Arc::strong_count(\u0026amp;task) == 1); take_cancelled_chiled_thread(task); schedule(\u0026amp;mut TaskContext::empty() as *mut _); unreachable!() } è¿™ä¸ªè¿‡ç¨‹æœ¬èº«å…¶å®å¯ä»¥ä¸ç”¨åšï¼Œè€Œæ˜¯ç­‰ä¸»çº¿ç¨‹è¿›è¡Œ wait ç³»ç»Ÿè°ƒç”¨æ—¶å½»åº•å›æ”¶ã€‚ä½†ç”±äºæµ‹è¯•è¿‡ç¨‹ä¸­ï¼Œè¿›ç¨‹ä¼šåˆ›å»ºæˆåƒä¸Šä¸‡ä¸ªå­çº¿ç¨‹ï¼Œå¦‚æœè¿™äº›çº¿ç¨‹èµ„æºæ²¡æœ‰åŠæ—¶å›æ”¶ï¼Œå¦‚ TrapContext, KenerlStack ç­‰èµ„æºï¼Œä¼šæµªè´¹è®¸å¤šå†…å­˜èµ„æºã€‚\nå…¶å® take_cancelled_chiled_thread(task)è¿™æ®µä»£ç æœ¬èº«ï¼Œä»¥åŠ CHILDREN_THREAD_MONITORå˜é‡ï¼Œä¹Ÿå°±æ˜¯è¯´è¿™æ®µä»£ç æœ¬èº«å…¶å®å¯ä»¥ç›´æ¥æ”¹ä¸º drop(task)ï¼Œå› ä¸ºæ­¤æ—¶ task å¼ºå¼•ç”¨è®¡æ•°ä¸€å®šä¸º 1ï¼Œtask ä¸­å¯ä»¥é‡Šæ”¾çš„èµ„æºéƒ½å¯ä»¥åœ¨, schedule ä¹‹å‰é‡Šæ”¾æ‰ä½†æ˜¯ task åœ¨æ‰§è¡Œ exit_current_and_run_nextæ—¶æœ¬èº«å‡ºäºå†…æ ¸æ€ï¼Œæ­¤æ—¶å›æ”¶ task çš„ KerenlStack æ—¢ä¸ç¬¦åˆé€»è¾‘ï¼Œåˆæœ‰å¯èƒ½äº§ç”Ÿä¸€äº›éšæ‚£ï¼Œæ•…é€‰æ‹©ä½¿ç”¨ CHILDREN_THREAD_MONITOR åœ¨è°ƒåº¦æ—¶é‡Šæ”¾é€€å‡ºçš„çº¿ç¨‹ã€‚\n","date":"2023-08-01","permalink":"https://bitethedisk.github.io/post/process-thread/","tags":["process","thread","å…¨å›½èµ›I"],"title":"[å…¨å›½èµ›I] è¿›ç¨‹ç®¡ç†-è¿›ç¨‹ä¸çº¿ç¨‹"},{"content":"ä¸€å¼€å§‹\n","date":"2023-07-12","permalink":"https://bitethedisk.github.io/post/opensbi-getchar/","tags":["å…¨å›½èµ›I"],"title":"é€‚é… OpenSBI"},{"content":"Rust å’Œ C äº¤äº’çš„æ—¶å€™éœ€è¦æ³¨æ„ Rust çš„å †ï¼Œå½“ä» Rust ç¨‹åº fork å‡ºä¸€ä¸ªè¿›ç¨‹ æ¥æ‰§è¡Œ C ç¨‹åºçš„æ—¶å€™ï¼ŒC æ˜¯ä¸èƒ½è¯†åˆ« Rust çš„å †çš„(åŒ…æ‹¬å…¶å †ç®¡ç†å™¨è¿™äº›)ï¼Œæ‰€ä»¥å½“ ä½¿ç”¨ C ç¨‹åºå»è®¿é—® fork åçš„ Rust å †ä¸Šçš„å¯¹è±¡ï¼Œæˆ–è€…ä¼ é€’ç›¸å…³å †ä¸Šå¯¹è±¡çš„æ—¶å€™å¯èƒ½ ä¼šäº§ç”Ÿè‡´å‘½é—®é¢˜(å¦‚éæ³•å†…å­˜è®¿é—®\u0026mdash;è®¿é—®è¶Šç•Œ)\n","date":"2023-07-07","permalink":"https://bitethedisk.github.io/post/rust-heap-and-c/","tags":null,"title":"Rust Heap and C"},{"content":"éšç€å¼€å‘çš„è¿›è¡Œï¼Œæˆ‘ä»¬éœ€è¦çš„é€‚é…å’Œå°è£…çš„æ•°æ®ç»“æ„è¶Šæ¥è¶Šå¤šï¼Œå…¶ä¸­å¤§éƒ¨åˆ†ä¸æˆ‘ä»¬çš„å†…æ ¸æœ¬ä½“å…³ç³»å¹¶æ²¡æœ‰é‚£ä¹ˆç´§å¯†ï¼Œ æ‰€ä»¥æˆ‘ä»¬å°†è¿™éƒ¨åˆ†ç»“æ„ï¼Œå¦‚ç”¨äºçš„å¼•å¯¼ç¨‹åºã€FAT32ã€Linux ç›¸å…³æ•°æ®ç»“æ„æ”¾åœ¨äº†é¡¹ç›®æ ¹ç›®å½•ä¸­çš„ crates é‡Œ\nRust æœ¬èº«æ˜¯æ”¯æŒå¤šä¸ª crates æ„æˆçš„ä¸€ä¸ª workspaceï¼Œè¿™äº› crates ç›´æ¥å¯ä»¥ç›¸äº’å¼•ç”¨ï¼Œä½†æ˜¯ç”±äºæˆ‘ä»¬ä½¿ç”¨ äº† .cargo/config.toml æ¥é…ç½® rustcï¼Œæ‰€ä»¥ workspace å¹¶ä¸èƒ½ä¸ºæˆ‘ä»¬æ‰€æœ‰ (å› ä¸ºç›®å‰ workspace ä¸æ”¯æŒåœ¨ workspace ä¸­è¯»å– .cargo/config.toml)\nä½¿ç”¨ Git Submodule ç®¡ç†æµ‹ä¾‹ ä¸åŒºåŸŸèµ›ä¸åŒï¼Œå…¨å›½èµ›çš„æµ‹ä¾‹æ•°ç›®è¾ƒå¤šï¼Œå¦‚æœä¸€æ—¦å‘ç”Ÿæ›´æ–°æ„å»ºèµ·æ¥ä¹Ÿç›¸å¯¹éº»çƒ¦\nåŸºäº Git Submodule æˆ‘ä»¬å¯ä»¥æ–¹ä¾¿éš”ç¦»å½“å‰ Git ä»“åº“ï¼Œåšåˆ°ä¾èµ–çš„éš”ç¦»ä¸åŒæ­¥\nå°±å½“å‰çš„å®é™…ç¯å¢ƒæ¥è¯´:\ngit submodule add https://github.com/oscomp/testsuits-for-oskernel.git testsuits ä¸Šé¢çš„ä½œç”¨æ˜¯å°† testsuits-for-oskernel.git clone åˆ°æœ¬åœ°çš„ testsuits æ–‡ä»¶å¤¹ä¸­ï¼Œåè€…ä¼šè‡ªåŠ¨åˆ›å»º\nå½“é‡æ–°æ‹‰å–é¡¹ç›®ä»“åº“æ—¶:\ngit submodule init git submodule update å°±å¯ä»¥é‡æ–°æ‹‰å– testsuits ä¸­ï¼Œä»“åº“çš„å†…å®¹äº†\né¡¹ç›®ç›®å½•æ ‘ . â”œâ”€â”€ Makefile â”œâ”€â”€ README.md â”œâ”€â”€ crates â”‚Â â”œâ”€â”€ fat32/ ---- FAT32 è¯»å†™åº“ â”‚Â â”œâ”€â”€ libd/ ---- libc çš„~~åç»§è€…(åˆ’æ‰)~~ initprocï¼Œå†…æ ¸è‡ªåŠ¨åŠ è½½çš„ç¬¬ä¸€ä¸ªç”¨æˆ·ç¨‹åº â”‚Â â”œâ”€â”€ nix/ ---- Linux ç›¸å…³æ•°æ®ç»“æ„ â”‚Â â””â”€â”€ sync_cell/ ---- å®ç°äº† Sync çš„ï¼Œå…·æœ‰å†…éƒ¨å¯å˜æ€§çš„ RefCell â”œâ”€â”€ docs/ â”œâ”€â”€ kernel/ â”‚Â â”œâ”€â”€ Makefile â”‚Â â”œâ”€â”€ build.rs ---- ç”¨äºç›‘æ§ç›¸å…³æ–‡ä»¶ï¼Œå¦‚ `crates/libd/bin/initproc.rs`ï¼Œå‘ç”Ÿå˜åŒ–æ—¶é‡æ–°ç¼–è¯‘ â”‚Â â”œâ”€â”€ cargo â”‚Â â”‚Â â””â”€â”€ config.toml â”‚Â â”œâ”€â”€ linkerld â”‚Â â”‚Â â””â”€â”€ linker.ld â”‚Â â”œâ”€â”€ src â”‚Â â”‚Â â”œâ”€â”€ boards â”‚Â â”‚Â â”‚Â â””â”€â”€ qemu.rs ---- å¹³å°ç›¸å…³å‚æ•° â”‚Â â”‚Â â”œâ”€â”€ console.rs â”‚Â â”‚Â â”œâ”€â”€ consts.rs â”‚Â â”‚Â â”œâ”€â”€ drivers â”‚Â â”‚Â â”œâ”€â”€ entry.S â”‚Â â”‚Â â”œâ”€â”€ error.rs â”‚Â â”‚Â â”œâ”€â”€ fs/ â”‚Â â”‚Â â”œâ”€â”€ logging.rs â”‚Â â”‚Â â”œâ”€â”€ macros â”‚Â â”‚Â â”‚Â â”œâ”€â”€ hsm.rs â”‚Â â”‚Â â”‚Â â”œâ”€â”€ mod.rs â”‚Â â”‚Â â”‚Â â”œâ”€â”€ on_boot.rs â”‚Â â”‚Â â”‚Â â””â”€â”€ profile.rs ---- ç”¨äºæ‰“å°æŸæ®µä»£ç è¿è¡Œæ—¶é—´çš„å® â”‚Â â”‚Â â”œâ”€â”€ main.rs â”‚Â â”‚Â â”œâ”€â”€ mm â”‚Â â”‚Â â”œâ”€â”€ sbi.rs â”‚Â â”‚Â â”œâ”€â”€ syscall/ â”‚Â â”‚Â â”œâ”€â”€ task/ â”‚Â â”‚Â â”œâ”€â”€ timer.rs â”‚Â â”‚Â â””â”€â”€ trap/ â”‚Â â”œâ”€â”€ target/ ---- æ„å»ºäº§ç‰© â”‚Â â””â”€â”€ vendor/ ---- æ‰€æœ‰ç¬¬ä¸‰æ–¹ä¾èµ–çš„æœ¬åœ°å½’æ¡£ â”œâ”€â”€ testsuits/ ---- é€šè¿‡ Git Submodule å†…è”çš„å®˜æ–¹æµ‹ä¾‹ â””â”€â”€ workspace ---- ç”¨äºä¸­é—´è¿‡ç¨‹æ„å»ºå†…æ ¸è¿è¡Œæ‰€éœ€æµ‹ä¾‹ 1187 directories, 9162 files ","date":"2023-06-30","permalink":"https://bitethedisk.github.io/post/project-structure/","tags":["å…¨å›½èµ›I","RustWorkspace"],"title":"[å…¨å›½èµ›I]é¡¹ç›®ç»“æ„(rust-workspaceä¸èƒ½ä½¿ç”¨)"},{"content":"é¡¹ç›®æä¾›äº†ä¸€ç³»åˆ—çš„ Makefile æ¥ç®€åŒ–å¼€å‘æµç¨‹.\nä¸€èˆ¬åªä¼šç”¨åˆ°é¡¹ç›®æ ¹ç›®å½•ä¸­çš„ Makefile:\nBOOTLOADER_ELF = ./kernel/bootloader/rustsbi-qemu KERNEL_ELF = ./kernel/target/riscv64gc-unknown-none-elf/release/kernel sbi-qemu: @cp $(BOOTLOADER_ELF) sbi-qemu kernel-qemu: @mv kernel/cargo kernel/.cargo @cd kernel/ \u0026amp;\u0026amp; make kernel @cp $(KERNEL_ELF) kernel-qemu all: sbi-qemu kernel-qemu clean: @rm -f kernel-qemu @rm -f sbi-qemu @rm -rf build/ @rm -rf temp/ @cd kernel/ \u0026amp;\u0026amp; cargo clean @cd workspace/ \u0026amp;\u0026amp; make clean @cd fat32/ \u0026amp;\u0026amp; cargo clean @cd misc/ \u0026amp;\u0026amp; make clean fat32img: @cd kernel/ \u0026amp;\u0026amp; make fat32img run: @cd kernel/ \u0026amp;\u0026amp; make run debug-server: @cd kernel/ \u0026amp;\u0026amp; make debug-server debug: @cd kernel/ \u0026amp;\u0026amp; make debug è¿™é‡Œåªéœ€å…³æ³¨ä»¥ä¸‹å‡ ç‚¹:\nrun: æ„å»ºå†…æ ¸å¹¶è¿è¡Œï¼Œå†…æ ¸æ˜¯ä»¥ release æ–¹å¼æ„å»ºçš„ debug-server: ä»¥ debug æ–¹å¼æ„å»ºå†…æ ¸å¹¶è¿è¡Œ gdb debug server debug: é“¾æ¥ä¸Šé¢è¿è¡Œçš„ debug server å¼€å§‹è°ƒè¯• ","date":"2023-06-30","permalink":"https://bitethedisk.github.io/post/about-makefile/","tags":["Makefile","Debug","åŒºåŸŸèµ›"],"title":"[åŒºåŸŸèµ›] æœ‰å…³ BTD çš„ Makefile"},{"content":"åœ¨ BTD çš„å¼€å‘ä¸­ç»å¸¸ä¼šé‡åˆ° debug çš„éœ€æ±‚ï¼ŒBTD æä¾›äº†ä¸€ä¸ªæ–¹ä¾¿çš„è°ƒè¯•æµç¨‹ï¼Œåªéœ€å¯åŠ¨ä¸¤ä¸ª shell å³å¯ å¼€å§‹è°ƒè¯•\nä¸‹é¢å°†æ¼”ç¤ºä¸€æ¬¡å…·ä½“çš„è°ƒè¯•æµç¨‹\nå¯åŠ¨ä¸¤ä¸ª shellï¼Œåœ¨é¡¹ç›®æ ¹ç›®å½•ä¸‹åˆ†åˆ«è¿è¡Œ make debug-server å’Œ make debugï¼Œ ä¹‹ååªéœ€è¦åœ¨è¿è¡Œ make debug çš„ shell ä¸­æ‰§è¡Œæ¥ä¸‹æ¥çš„å‘½ä»¤å³å¯ # ä»å½“å‰ pc å¼€å§‹æ˜¾ç¤º 11 æ¡æŒ‡ä»¤ï¼Œ11 æ¡æ˜¯ä¸å‘ç”ŸæŠ˜å çš„æé™ï¼ˆä¹Ÿå¯èƒ½åªæ˜¯æˆ‘è¿™æ˜¯è¿™æ ·ï¼‰ (gdb) x/11i $pc (gdb) b *0x80000000 # åœ¨å†…æ ¸ç¬¬ä¸€æ¡æŒ‡ä»¤å¤„æ‰“ä¸ªæ–­ç‚¹ (gdb) c # continue æ‰§è¡Œåˆ°æ–­ç‚¹å¤„ (gdb) si # si å•æ­¥æ‰§è¡Œ (step inï¼Œä¼šåµŒå…¥å‡½æ•°å…·ä½“æµç¨‹ä¸­) éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨å¤šæ ¸è¿è¡Œæ—¶ï¼Œä»£ç æ‰§è¡Œè¿‡ç¨‹ä¸­ä¼šå‡ºç°ç³»ç»Ÿçº¿ç¨‹çš„åˆ‡æ¢ï¼Œä¾‹å¦‚ä¸‹é¢è¿™æ ·ï¼š\n(gdb) c Continuing. [Switching to Thread 1.2] è¿™æ—¶å€™æˆ‘ä»¬è¦çœ‹å½“å‰çº¿ç¨‹çš„çŠ¶æ€ï¼Œæ ¹æ®å½“å‰çŠ¶æ€è¿›è¡Œè°ƒè¯•ï¼Œè¯¥æ‰“æ–­ç‚¹çš„åœ°æ–¹ä¸è¦å¿˜äº†æ‰“æ–­ç‚¹ï¼Œä¸ç„¶ä¼šè·‘é£\nåƒæ˜¯è¿™æ ·ï¼Œåªèƒ½ç”¨ Ctrl + C æ¥ææ­» (ä¸»è¦æ˜¯æˆ‘ä¹Ÿæ²¡å»æ‰¾å…¶ä»–å¯èƒ½çš„æ–¹æ³• ğŸ˜›):\nçœ‹åˆ°åœ°å€äº†å—ï¼Œç›´æ¥å½’é›¶ï¼Œè€Œä¸”è¿™å—åœ°å€æ˜¯ä¸å¯è®¿é—®çš„ï¼Œåªèƒ½å¡åœ¨è¿™äº†ï¼Œé™¤éæ‰¬äº†å½“å‰çš„ shell é‡æ¥ï¼ˆå¤§æ¦‚\nThread 2 received signal SIGINT, Interrupt. 0x0000000000000000 in ?? () (gdb) x/11i $pc =\u0026gt; 0x0: Cannot access memory at address 0x0 (gdb) ","date":"2023-06-30","permalink":"https://bitethedisk.github.io/post/how-to-debug-the-kernel/","tags":["OSKernel","Debug"],"title":"å¼€å‘ä¸­å¦‚è°ƒè¯•å†…æ ¸"},{"content":"å†…æ ¸åœ¨è¿è¡Œçš„æ—¶å€™æ€»æ˜¯ä¼šä¸çŸ¥ä½•æ—¶å¡æ­»ï¼Œåº•å±‚åŸå› æ˜¯æŒç»­è§¦å‘æ—¶é’Ÿä¸­æ–­\n// æ—¶é—´ç‰‡åˆ°äº† Trap::Interrupt(Interrupt::SupervisorTimer) =\u0026gt; { set_next_trigger(); // ä¸»è¦æ˜¯è¿™é‡Œ suspend_current_and_run_next(); } åˆæ­¥è§£å†³ æˆ‘ä»¬å°†è®¾ç½®ä¸‹ä¸€ä¸ªæ—¶é’Ÿä¸­æ–­æ”¾ç½®åœ¨äº† suspend_current_and_run_next ä¹‹å‰ï¼Œå¯¼è‡´å¯èƒ½å› ä¸ºåè€…æ‰§è¡Œ æ—¶é—´è¿‡é•¿è€Œä½¿ç”¨æˆ·æ€ä¸€ç›´å¤„äºæ—¶é’Ÿä¸­æ–­è§¦å‘çŠ¶æ€ï¼Œè‡³äºä¸ºä»€ä¹ˆä¼šåœ¨ RV64 ä¸Šä¸€ç›´è§¦å‘ä¸­æ–­ï¼Œå¯ä»¥å‚é˜… RV çš„ç‰¹æƒçº§æ‰‹å†Œ:\nPlatforms provide a real-time counter, exposed as a memory-mapped machine-mode read-write register, mtime. mtime must increment at constant frequency, and the platform must provide a mechanism for determining the period of an mtime tick. The mtime register will wrap around if the count overflows.\nThe mtime register has a 64-bit precision on all RV32 and RV64 systems. Platforms provide a 64- bit memory-mapped machine-mode timer compare register (mtimecmp). A machine timer interrupt becomes pending whenever mtime contains a value greater than or equal to mtimecmp, treating the values as unsigned integers. The interrupt remains posted until mtimecmp becomes greater than mtime (typically as a result of writing mtimecmp). The interrupt will only be taken if interrupts are enabled and the MTIE bit is set in the mie register.\nç”±äº suspend_current_and_run_next æ‰§è¡Œçš„æ—¶é—´è¶…è¿‡äº†ä¸€ä¸ªæ—¶é—´ç‰‡çš„é•¿åº¦ï¼Œå¯¼è‡´å…¶è¿”å›ç”¨æˆ·æ€è¿›ç¨‹æ—¶ï¼Œ mtime çš„å€¼å·²ç»å¤§äºäº† set_next_trigger è®¾ç½®çš„æ—¶é—´ç‚¹ï¼Œç”±ä¸Šæ–‡å¯å¾—ï¼Œå¦‚æœ mtime å¤§äºç­‰äº mtimecmp(å³ set_next_trigger è®¾ç½®çš„å€¼)ï¼Œå¹¶ä¸” mie ä¸ºä½¿èƒ½çŠ¶æ€ï¼Œé‚£ä¹ˆæ—¶é’Ÿä¸­æ–­ä¼šä¸€ç›´å¤„äºè§¦å‘çŠ¶æ€.\nè€Œæˆ‘ä»¬çš„å†…æ ¸ mie ä¸€ç›´å¤„äºä½¿èƒ½çŠ¶æ€ï¼Œæ‰€ä»¥ S æ€çš„æ—¶é’Ÿä¸­æ–­ä¼šæŒç»­åœ¨ç”¨æˆ·æ€å‘ç”Ÿ(S æ€ä¸­æ–­ä¸ä¼šæ‰“æ–­åŒçº§ä¸ æ›´é«˜ç‰¹æƒçº§ä»£ç çš„æ‰§è¡Œ)ï¼Œå¯¼è‡´ç”¨æˆ·æ€æ¯«æ— è¿›å±•ï¼Œè€Œæˆ‘ä»¬å†…æ ¸çš„å¼•å¯¼ç¨‹åº initproc ä¼šä¸€ç›´ç­‰å¾…å¡æ­»ç”¨æˆ·è¿›ç¨‹ å˜ä¸ºåƒµå°¸æ€ï¼Œæ‰€ä»¥é€ æˆäº†å†…æ ¸æ‰§è¡Œæµçš„å¡æ­».\nè§£å†³åŠæ³•:\nç®€å•è°ƒæ•´ä¸‹ä½ç½®\nTrap::Interrupt(Interrupt::SupervisorTimer) =\u0026gt; { suspend_current_and_run_next(); set_next_trigger(); } ä½†è¿™æ ·çœŸçš„å¯¹å—? ä¸å¯¹ï¼Œå› ä¸ºä¼šå¯¼è‡´ç”¨æˆ·æ€ç¨‹åºå¡æ­»æ•´ä¸ªå†…æ ¸çš„æ‰§è¡Œæµ\nä¸€ä¸ªè‡´å‘½çš„ç¼ºç‚¹æ˜¯ï¼Œç”¨æˆ·æ€çš„ç¨‹åºéœ€è¦ç¬¬ä¸€æ¬¡è¿è¡Œåæ‰èƒ½æ­£ç¡®çš„è·å–æ—¶é’Ÿä¸­æ–­ï¼Œä¸ç„¶åªèƒ½ç­‰è½®å›ä¸€è¾¹åæ‰å¯èƒ½æ­£ç¡®è®©å‡º\nå½“å‰çš„é€»è¾‘æ˜¯:\nRustSBI å®Œæˆåˆå§‹åŒ–åï¼Œåœ¨ meow(æ²¡é”™ï¼Œè¿™æ˜¯æˆ‘ä»¬ Rust ä»£ç çš„ ENTRYPOINT)ï¼Œä¸­åˆæ­¥è®¾å®šä¸€ä¸ªæ—¶é’Ÿä¸­æ–­\n#[cfg(not(feature = \u0026quot;multi_harts\u0026quot;))] #[no_mangle] pub fn meow() -\u0026gt; ! { if hartid!() == 0 { init_bss(); unsafe { set_fs(FS::Dirty) } lang_items::setup(); logging::init(); mm::init(); trap::init(); trap::enable_stimer_interrupt(); trap::set_next_trigger(); fs::init(); task::add_initproc(); task::run_tasks(); } else { loop {} } unreachable!(\u0026quot;main.rs/meow: you should not be here!\u0026quot;); } è¿™æ˜¯ç¬¬ä¸€ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬åŸæœ¬æƒ³çš„æ˜¯ï¼Œè¿™ä¸ªæ—¶é’Ÿä¸­æ–­ä¼šåœ¨ç¬¬ä¸€ç”¨æˆ·æ€ç¨‹åºè¿è¡Œæ—¶å‘ç”Ÿï¼Œä½†æ˜¯æœ‰å¯èƒ½å®ƒåœ¨ fs::init() æˆ–è€… task::add_initproc() ä¸­å·²ç»å‘ç”Ÿäº†ï¼Œè¿™ä¼šå¯¼è‡´ä¸€è¿›å…¥ç”¨æˆ·æ€ç¨‹åºå°±å‘ç”Ÿä¸­æ–­ï¼Œè¿™å’Œæˆ‘ä»¬ é¢„æœŸçš„ä¸ä¸€æ ·.\nè€Œä¸”ï¼Œé™·å…¥ä¸­æ–­åï¼Œé™¤éä½¿å¤±èƒ½ mieï¼Œæˆ–è€…å†æ¬¡ set_next_trigger()(åˆæˆ–è€… mtime å‘ç”Ÿå›ç¯)ï¼Œ å¦åˆ™å°†ä¸€ç›´å¤„äºä¸­æ–­è§¦å‘çš„çŠ¶æ€\nè€Œè¿™ä¹‹ååˆ‡æ¢çš„ç”¨æˆ·è¿›ç¨‹éƒ½ä¼šé‡åˆ°ä¸­æ–­è€Œç›´æ¥è¿”å›ï¼Œç›´åˆ°è¿è¡Œåˆ°ç¬¬ä¸€ä¸ªç”¨æˆ·è¿›ç¨‹(å…¶å®åº”è¯¥æ˜¯å¼•å¯¼ç¨‹åº initproc)ï¼Œ åœ¨ä¸‹é¢ suspend_current_and_run_next çœŸæ­£æ„ä¹‰ä¸Šçš„è¿”å›åï¼Œé‡æ–°è®¾ç½®ä¸‹ä¸€ä¸ªä¸­æ–­æ—¶é—´ç‚¹ï¼Œè¿™æ‰èƒ½è®© OS å†…æ ¸ æ‰€æœ‰çš„ç”¨æˆ·è¿›ç¨‹è¿›å…¥æ­£å¸¸çš„è¿è¡Œæµ.\nTrap::Interrupt(Interrupt::SupervisorTimer) =\u0026gt; { suspend_current_and_run_next(); set_next_trigger(); } è€Œè¿™ç§æ—¶é—´ä¸Šçš„å¼€é”€æ˜¾ç„¶æ˜¯æ²¡å¿…è¦çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬æ ¹æ®æ‰€æœ‰ç”¨æˆ·è¿›ç¨‹éƒ½ä¼šé€šè¿‡ trap_return è¿”å›ç”¨æˆ·æ€è¿™ä¸€ç‚¹ï¼Œ å°† set_next_trigger è®¾ç½®åœ¨äº† trap_return ä¸­ï¼ŒåŒæ—¶åˆ¤æ–­å½“å‰è¿›ç¨‹æ˜¯å¦æ˜¯å› ä¸ºæ—¶é—´ç‰‡è€—å°½è€Œå¯¼è‡´çš„ trap è¿”å›:\nTrap::Interrupt(Interrupt::SupervisorTimer) =\u0026gt; { suspend_current_and_run_next(); } // ... #[no_mangle] pub fn trap_return() -\u0026gt; ! { // ... if is_time_intr_trap() { set_next_trigger(); } // ... } /// æ˜¯å¦æ˜¯ç”±äºæ—¶é—´ç‰‡è€—å°½å¯¼è‡´çš„ trap fn is_time_intr_trap() -\u0026gt; bool { let scause = scause::read(); scause.cause() == Trap::Interrupt(scause::Interrupt::SupervisorTimer) } æœ€ç»ˆç»“æœ æˆ‘ä»¬æ¶ˆé™¤äº†ä¸€ä¸ªä¸¥é‡çš„ bug: å†…æ ¸åœ¨æ‰§è¡Œç”¨æˆ·ç¨‹åºæ—¶éšæœºå¡æ­» åˆ å»äº† meow ä¸­ä¸åˆ©äºç³»ç»Ÿé²æ£’æ€§çš„ä»£ç  ","date":"2023-06-29","permalink":"https://bitethedisk.github.io/post/random-stuck/","tags":["Problems-\u0026-Solutions"],"title":"[å·²è§£å†³]å†…æ ¸åœ¨æ‰§è¡Œç”¨æˆ·ç¨‹åºæ—¶éšæœºå¡æ­»"}]