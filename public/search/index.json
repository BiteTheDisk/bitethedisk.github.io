[{"content":"åº”ç”¨ç¨‹åºçš„ä¸€æ¬¡æ‰§è¡Œè¿‡ç¨‹ç§°ä¸ºä¸€ä¸ªä»»åŠ¡ã€‚\nåœ¨ BTD-OS ä¸­æˆ‘ä»¬å°†è¿›ç¨‹å’Œçº¿ç¨‹ç»Ÿä¸€ç”¨ä»»åŠ¡æ§åˆ¶å— (TaskContralBlock) ç»“æ„è¡¨ç¤ºï¼Œç»´æŠ¤ç€æ“ä½œç³»ç»Ÿå¯¹äºä»»åŠ¡çš„ç®¡ç†ä¿¡æ¯ï¼Œç»“æ„å¦‚ä¸‹ï¼š\n// branch-main: kernel/src/task/task.rs pub struct TaskControlBlock { // immutable pub pid: PidHandle, pub tgid: usize, pub kernel_stack: KernelStack, // mutable according to clone flags pub sigactions: Arc\u0026lt;RwLock\u0026lt;[SigAction; MAX_SIGNUM as usize]\u0026gt;\u0026gt;, pub memory_set: Arc\u0026lt;RwLock\u0026lt;MemorySet\u0026gt;\u0026gt;, pub fd_table: Arc\u0026lt;RwLock\u0026lt;FDTable\u0026gt;\u0026gt;, // mutable inner: RwLock\u0026lt;TaskControlBlockInner\u0026gt;, } pid / tgid ç”±å…¨å±€åˆ†é…å™¨ PID_ALLOCATOR åˆ†é…ï¼Œå¹¶ä¸”åˆ†é…çš„ ID ä»…å¢é•¿ä¸å›æ”¶ï¼Œå› ä¸º BTD-OS å®ç°çº¿ç¨‹çš„è¿‡ç¨‹ä¸­ï¼Œé»˜è®¤è®¤ä¸º tgid ä¸å°äº pidï¼› è‹¥è¯¥ä»»åŠ¡æ§åˆ¶å—ä¸ºè¿›ç¨‹ï¼Œåˆ™ TaskControlBlock çš„ pid ä¸ tgid å­—æ®µå€¼ç›¸åŒï¼› pid ä¸ tgid çš„å·®å€¼å¯ä»¥ç”¨äºè®¡ç®—çº¿ç¨‹ TrapContext è™šæ‹Ÿåœ°å€ï¼› kernel_stack å­—æ®µä»…ç”¨äºåˆ›å»ºæ—¶åˆ†é…å†…æ ¸æ ˆï¼Œæ•…æ— éœ€ä¿®æ”¹ï¼› sigactions, memory_set, fd_table å­—æ®µå‡éœ€è¦æ ¹æ® fork æ—¶çš„ CloneFlags å‚æ•°ç»“åˆ man-page è¦æ±‚åˆ›å»ºï¼› pub struct TaskControlBlockInner { pub trap_cx_ppn: PhysPageNum, pub task_cx: TaskContext, pub task_status: TaskStatus, pub trap_cause: Option\u0026lt;Scause\u0026gt;, pub parent: Option\u0026lt;Weak\u0026lt;TaskControlBlock\u0026gt;\u0026gt;, // child process and thread collection pub children: Vec\u0026lt;Arc\u0026lt;TaskControlBlock\u0026gt;\u0026gt;, pub pending_signals: SigSet, pub sigmask: SigMask, pub cwd: AbsolutePath, pub exit_code: i32, pub interval_timer: Option\u0026lt;IntervalTimer\u0026gt;, pub utime: TimeVal, pub stime: TimeVal, pub last_enter_umode_time: TimeVal, pub last_enter_smode_time: TimeVal, pub robust_list: RobustList, pub rlimit_nofile: RLimit, pub clear_child_tid: usize, /* CLONE_CHILD_CLEARTID */ } trap_cause ç”¨äºè®°å½• TCB è¿›å…¥ trap_handler çš„åŸå› ï¼ŒBTD-OS å…·ä½“ç”¨äºæ—¶é’Ÿä¸­æ–­æ›´æ–°æ—¶é—´ç‰‡çš„é—®é¢˜ï¼ˆåæ–‡ä¼šä»‹ç» BTD-OS ä¸ºä½•æ”¹è¿›æ—¶é’Ÿä¸­æ–­å¤„ç†ï¼‰ï¼› parent è¡¨ç¤ºå¯èƒ½å­˜åœ¨çš„çˆ¶è¿›ç¨‹ï¼› children ç”¨äºæ”¶é›† fork æ—¶åˆ›å»ºçš„å­è¿›ç¨‹/å­çº¿ç¨‹çš„ Arc (åŸå­å¼•ç”¨è®¡æ•°)ï¼› pending_signals è¡¨ç¤ºå¾…å¤„ç†çš„ä¿¡å·é›†ï¼› sigmask è¡¨ç¤ºè¢«å±è”½çš„ä¿¡å·é›†ï¼› interval_timer ç”¨äºå¤„ç†ä¸å®šæ—¶å™¨ç›¸å…³çš„ç³»ç»Ÿè°ƒç”¨ï¼› utime, stime, last_enter_umode_time, last_enter_smode_time ç”¨äºè®°å½• TCB åˆ†åˆ«åœ¨ U Mode å’Œ S Mode ä¸‹æ‰€è€—è´¹çš„æ—¶é—´ï¼Œç”¨äºå¤„ç† getrusage ç³»ç»Ÿè°ƒç”¨ï¼› robust_list ç”¨äºå®ç° get_robust_listï¼Œset_robust_list ç³»ç»Ÿè°ƒç”¨ rlimit_nofile ç”¨äºå®ç° rlimit ç›¸å…³ç³»ç»Ÿè°ƒç”¨ï¼Œä½†ç›®å‰ä»…ç”¨äºé™åˆ¶è¿›ç¨‹å¯æ‰“å¼€çš„æ–‡ä»¶æ•° clear_child_tid ç”¨äºå®ç° forkï¼Œset_tid_address ç³»ç»Ÿè°ƒç”¨ å¦å¤–ï¼Œæˆ‘ä»¬åœ¨å‚è€ƒå¾€å±Šä¼˜ç§€ä½œå“å®ç°æ—¶ï¼Œæœ‰æ³¨æ„åˆ°æœ‰äº›é˜Ÿä¼åœ¨ TCB ä¸­ä¿ç•™äº† user_stask å­—æ®µã€‚è¯¥å­—æ®µç”¨äºä¿å­˜ä¸ºçº¿ç¨‹åˆ†é…ç”¨æˆ·æ ˆæ—¶ä¿ç•™çš„ user_stack è™šæ‹Ÿåœ°å€ã€‚\nBTD-OS çš„ TCB ä¸­å¹¶æ²¡æœ‰ä¿å­˜ï¼ŒåŸå› æ˜¯æŒ‰ç…§ man-page å…³äº fork(clone) ç³»ç»Ÿè°ƒç”¨çš„è§„å®šå¯¹äºå…±äº«å†…å­˜çš„å­è¿›ç¨‹æˆ–å­çº¿ç¨‹ï¼Œåˆ›å»ºä¼ å…¥ stask å‚æ•°ï¼Œè¯¥å‚æ•°è§„å®šäº†å­è¿›ç¨‹/çº¿ç¨‹çš„ç”¨æˆ·æ ˆçš„ä½ç½®ï¼Œæ•…å®é™…ä¸Šä¸éœ€è¦æˆ‘ä»¬é¢å¤–åˆ›å»º user_stackã€‚\nå¯¹äºé forK(clone) åˆ›å»ºçš„è¿›ç¨‹ï¼ˆnew/exec load_elf æ–¹æ³•ä¸­ï¼‰ï¼ŒBTD-OS ä¼šåˆ†é…å¹¶æ˜ å°„è¯¥è¿›ç¨‹çš„ user_stackã€‚\n// kernel/src/mm/memory_set.rs: fn load_elf memory_set.user_stack_areas = VmArea::new( user_stack_bottom.into(), user_stack_top.into(), MapType::Framed, VmAreaType::UserStack, MapPermission::R | MapPermission::W | MapPermission::U, None, 0, ); ","date":"2023-08-19","permalink":"https://bitethedisk.github.io/post/task_control_block/","tags":null,"title":"ä»»åŠ¡æ§åˆ¶å—"},{"content":"RISC-Væ¶æ„å®šä¹‰äº†4ç§ç‰¹æƒçº§åˆ«ï¼Œå…¶ä¸­åªæœ‰Mæ¨¡å¼æ˜¯å¿…é¡»å®ç°çš„ï¼Œå…¶ä½™ç‰¹æƒçº§åˆ«å¯ä»¥æ ¹æ®è¿è¡Œåœ¨CPUä¸Šçš„åº”ç”¨éœ€æ±‚è¿›è¡Œè°ƒæ•´ã€‚\nBTD OSæ¶‰åŠM/S/Uä¸‰ç§ç‰¹æƒçº§åˆ«ï¼Œå¯ä»¥æ ¹æ®è¿è¡Œæ—¶çš„ç‰¹æƒçº§åˆ«åˆ†ä¸ºä¸‰ä¸ªéƒ¨åˆ†ï¼š\nç”¨æˆ·/åº”ç”¨æ¨¡å¼ (U, User/Application)ï¼šç”¨æˆ·åº”ç”¨ç¨‹åºè¿è¡Œåœ¨ U æ€ã€‚å…·æœ‰æœ€ä½é™åº¦çš„æƒé™ï¼Œæ— æ³•è¯»å†™ç‰¹æƒçº§å¯„å­˜å™¨ï¼Œä¹Ÿæ— æ³•ä¿®æ”¹Sæ€å’ŒMæ€çš„å†…å­˜ç©ºé—´ï¼Œåªèƒ½é€šè¿‡ç³»ç»Ÿè°ƒç”¨æˆ–å¼‚å¸¸ä¸­æ–­ç­‰æ–¹å¼ä¸Sæ€è¿›è¡Œäº¤äº’ã€‚ ç›‘ç£æ¨¡å¼ (S, Supervisor)ï¼šæ“ä½œç³»ç»Ÿçš„å†…æ ¸è¿è¡Œåœ¨ S æ€ï¼Œæ˜¯ç”¨æˆ·ç¨‹åºçš„è¿è¡Œç¯å¢ƒã€‚åœ¨è¿™ä¸ªæ¨¡å¼ä¸‹ï¼Œå†…æ ¸éœ€è¦åè°ƒè°ƒåº¦è¿›ç¨‹ã€å“åº”ç”¨æˆ·çš„ç³»ç»Ÿè°ƒç”¨è¯·æ±‚ã€ç®¡ç†è¿›ç¨‹çš„å†…å­˜ç©ºé—´ä»¥åŠæ§åˆ¶è®¾å¤‡çš„IOæ“ä½œç­‰ã€‚ æœºå™¨æ¨¡å¼ (M, Machine)ï¼šç›‘ç£æ¨¡å¼æ‰§è¡Œç¯å¢ƒ (SEE, Supervisor Execution Environment) è¿è¡Œåœ¨ M æ¨¡å¼ä¸Šï¼Œè´Ÿè´£å®Œæˆä¸ç¡¬ä»¶ç›¸å…³çš„åˆå§‹åŒ–ç­‰å·¥ä½œï¼Œå¦‚åœ¨æ“ä½œç³»ç»Ÿè¿è¡Œå‰è´Ÿè´£åŠ è½½æ“ä½œç³»ç»Ÿçš„ Bootloader â€“ RustSBIï¼Œæ˜¯æ“ä½œç³»ç»Ÿå†…æ ¸çš„è¿è¡Œç¯å¢ƒã€‚ åœ¨ RISC-V ä¸­ï¼Œå„æ¨¡å¼ä½¿ç”¨ ecall æŒ‡ä»¤ä¸å¯¹åº”æ¨¡å¼ä¸‹çš„ ret æŒ‡ä»¤è¿›è¡Œç‰¹æƒçº§åˆ‡æ¢ï¼Œå¯¹äºç”¨æˆ·æ¨¡å¼ï¼ˆå³ç”¨æˆ·æ€ï¼‰åˆ‡ æ¢åˆ°ç›‘ç£æ¨¡å¼ï¼ˆå³å†…æ ¸æ€ï¼‰ï¼Œä¸»è¦æ˜¯ä½¿ç”¨å†…æ ¸æä¾›çš„æä¾›äº† ABIï¼ˆApplication Binary Interfaceï¼‰æ¥å£ï¼Œå³ BTD OS å®ç°çš„ç³»ç»Ÿè°ƒç”¨ã€‚å¯¹äºç›‘ç£æ¨¡å¼åˆ‡æ¢åˆ°æœºå™¨æ¨¡å¼ï¼Œæˆ‘ä»¬é€‰æ‹©ä½¿ç”¨ OpenSBIï¼Œå®ƒæ˜¯è¿è¡Œåœ¨æ›´åº•å±‚çš„ M æ¨¡å¼ç‰¹æƒçº§ä¸‹çš„è½¯ä»¶ï¼Œå®ç°äº†å¯¹ç¡¬ä»¶çš„æ§åˆ¶ï¼Œå¦‚ä¸²å£è¾“å…¥è¾“å‡ºã€å¤šæ ¸å¿ƒå¯åŠ¨ã€æ“ä½œç³»ç»Ÿçš„å…³æœºç­‰æ“ä½œï¼Œæ˜¯æ“ä½œç³»ç»Ÿå†…æ ¸çš„æ‰§è¡Œç¯å¢ƒã€‚\n! ç›®å½•æ ‘ä»‹ç» src â”œâ”€â”€ board â”‚ â”œâ”€â”€ fu740.rs â”‚ â”œâ”€â”€ mod.rs â”‚ â””â”€â”€ qemu.rs â”œâ”€â”€ boards â”‚ â””â”€â”€ qemu.rs â”œâ”€â”€ console.rs â”œâ”€â”€ consts.rs â”œâ”€â”€ drivers â”‚ â”œâ”€â”€ fu740 â”‚ â”‚ â”œâ”€â”€ mod.rs â”‚ â”‚ â”œâ”€â”€ plic.rs â”‚ â”‚ â”œâ”€â”€ prci.rs â”‚ â”‚ â”œâ”€â”€ sdcard.rs â”‚ â”‚ â””â”€â”€ spi.rs â”‚ â”œâ”€â”€ mod.rs â”‚ â””â”€â”€ qemu â”‚ â”œâ”€â”€ mod.rs â”‚ â”œâ”€â”€ virtio_blk.rs â”‚ â””â”€â”€ virtio_impl.rs â”œâ”€â”€ entry.S â”œâ”€â”€ fs â”‚ â”œâ”€â”€ fat32 â”‚ â”‚ â”œâ”€â”€ file.rs â”‚ â”‚ â””â”€â”€ mod.rs â”‚ â”œâ”€â”€ file.rs â”‚ â”œâ”€â”€ mod.rs â”‚ â”œâ”€â”€ mount.rs â”‚ â”œâ”€â”€ page.rs â”‚ â”œâ”€â”€ page_cache.rs â”‚ â”œâ”€â”€ pipe.rs â”‚ â””â”€â”€ stdio â”‚ â”œâ”€â”€ mod.rs â”‚ â”œâ”€â”€ stdin.rs â”‚ â””â”€â”€ stdout.rs â”œâ”€â”€ logging.rs â”œâ”€â”€ macros â”‚ â”œâ”€â”€ hsm.rs â”‚ â”œâ”€â”€ mod.rs â”‚ â”œâ”€â”€ on_boot.rs â”‚ â””â”€â”€ profile.rs â”œâ”€â”€ main.rs â”œâ”€â”€ mm â”‚ â”œâ”€â”€ address.rs â”‚ â”œâ”€â”€ frame_allocator.rs â”‚ â”œâ”€â”€ kernel_heap_allocator.rs â”‚ â”œâ”€â”€ kvmm.rs â”‚ â”œâ”€â”€ memory_set.rs â”‚ â”œâ”€â”€ mmap.rs â”‚ â”œâ”€â”€ mod.rs â”‚ â”œâ”€â”€ page_table.rs â”‚ â”œâ”€â”€ permission.rs â”‚ â”œâ”€â”€ shared_memory.rs â”‚ â”œâ”€â”€ user_buffer.rs â”‚ â””â”€â”€ vm_area.rs â”œâ”€â”€ panic.rs â”œâ”€â”€ sbi.rs â”œâ”€â”€ syscall â”‚ â”œâ”€â”€ dispatcher.rs â”‚ â”œâ”€â”€ errno.rs â”‚ â”œâ”€â”€ futex.rs â”‚ â”œâ”€â”€ impls â”‚ â”‚ â”œâ”€â”€ fs.rs â”‚ â”‚ â”œâ”€â”€ futex.rs â”‚ â”‚ â”œâ”€â”€ mm.rs â”‚ â”‚ â”œâ”€â”€ mod.rs â”‚ â”‚ â”œâ”€â”€ others.rs â”‚ â”‚ â””â”€â”€ process.rs â”‚ â””â”€â”€ mod.rs â”œâ”€â”€ task â”‚ â”œâ”€â”€ context.rs â”‚ â”œâ”€â”€ id.rs â”‚ â”œâ”€â”€ initproc â”‚ â”‚ â”œâ”€â”€ busybox â”‚ â”‚ â”œâ”€â”€ initproc.S â”‚ â”‚ â”œâ”€â”€ mod.rs â”‚ â”‚ â””â”€â”€ test_all_custom.sh â”‚ â”œâ”€â”€ kstack.rs â”‚ â”œâ”€â”€ manager â”‚ â”‚ â”œâ”€â”€ hanging_task.rs â”‚ â”‚ â”œâ”€â”€ mod.rs â”‚ â”‚ â””â”€â”€ task_manager.rs â”‚ â”œâ”€â”€ mod.rs â”‚ â”œâ”€â”€ processor â”‚ â”‚ â”œâ”€â”€ mod.rs â”‚ â”‚ â”œâ”€â”€ processor.rs â”‚ â”‚ â””â”€â”€ schedule.rs â”‚ â”œâ”€â”€ signal.rs â”‚ â”œâ”€â”€ switch â”‚ â”‚ â”œâ”€â”€ mod.rs â”‚ â”‚ â””â”€â”€ switch.S â”‚ â””â”€â”€ task.rs â”œâ”€â”€ timer.rs â””â”€â”€ trap â”œâ”€â”€ context.rs â”œâ”€â”€ handler.rs â”œâ”€â”€ mod.rs â””â”€â”€ trampoline.S ","date":"2023-08-19","permalink":"https://bitethedisk.github.io/post/overall_architecture/","tags":null,"title":"ç³»ç»Ÿè®¾è®¡ä¸æ•´ä½“æ¶æ„"},{"content":"BTD-OSæ˜¯ä¸€æ¬¾åŸºäº Rust è¯­è¨€å¼€å‘çš„å®å†…æ ¸æ“ä½œç³»ç»Ÿï¼Œé€‚ç”¨äº RISC-V64 å¹³å°ã€‚\nå®ƒå®ç°äº†ä¸­æ–­ä¸å¼‚å¸¸å¤„ç†ã€è¿›ç¨‹ç®¡ç†ã€å†…å­˜ç®¡ç†ã€æ–‡ä»¶ç³»ç»Ÿå’Œä¿¡å·ç³»ç»Ÿç­‰æ“ä½œç³»ç»ŸåŸºæœ¬æ¨¡å—ã€‚ç›®å‰ï¼ŒBTD-OS å¯ä»¥åœ¨ QEMU è™šæ‹Ÿç¯å¢ƒå’Œ HiFive Unmatched U740 æ¿å¡ä¸Šè¿è¡Œã€‚\nBTD-OS çš„æ ¸å¿ƒç›®æ ‡æ˜¯è®¾è®¡ä¸€æ¬¾ç®€æ´ã€å°å·§ã€ç»“æ„æ¸…æ™°ã€åŠŸèƒ½å®Œå–„ä¸”å…·æœ‰è‰¯å¥½å¯æ‹“å±•æ€§çš„æ“ä½œç³»ç»Ÿã€‚BiteTheDisk å›¢é˜Ÿåœ¨ä»£ç å’Œæ–‡æ¡£ä¸­å°½å¯èƒ½åœ°ä¿ç•™äº† BTD-OS çš„è®¾è®¡ä¸å®ç°æ€è·¯ï¼ŒåŒ…æ‹¬é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆä»¥åŠåç»­å¯èƒ½çš„ä¼˜åŒ–æ–¹æ¡ˆï¼Œä»¥å±•ç°æ“ä½œç³»ç»Ÿçš„åŸºæœ¬åŠŸèƒ½å’Œæ ¸å¿ƒæ€æƒ³ï¼Œæ–¹ä¾¿ä»–äººå­¦ä¹ å’Œå€Ÿé‰´ï¼ŒåŠ æ·±å¯¹æ“ä½œç³»ç»ŸåŸºæœ¬åŸç†ä¸å®ç°çš„ç†è§£ã€‚\nç¼–ç¨‹è¯­è¨€çš„é€‰æ‹© è™½ç„¶å¸¸è§çš„æ“ä½œç³»ç»Ÿå†…æ ¸éƒ½æ˜¯åŸºäº C è¯­è¨€çš„ï¼Œä½† BTD-OS ä½¿ç”¨ Rust è¯­è¨€è¿›è¡Œå¼€å‘ï¼ŒåŸå› å¦‚ä¸‹ï¼š\nå†…å­˜å®‰å…¨æ€§ï¼šRust æ˜¯ä¸€ç§å†…å­˜å®‰å…¨çš„ç¼–ç¨‹è¯­è¨€ï¼Œå…¶å€Ÿç”¨æ£€æŸ¥å™¨ï¼ˆBorrow Checkerï¼‰å¯ä»¥åœ¨ç¼–è¯‘æ—¶æ•è·å†…å­˜è®¿é—®é”™è¯¯ï¼Œé¿å…äº†å¸¸è§çš„å†…å­˜å®‰å…¨é—®é¢˜ï¼Œå¦‚ç©ºæŒ‡é’ˆå¼•ç”¨ã€æ•°æ®ç«äº‰ç­‰ã€‚ æ€§èƒ½ï¼šRust è¯­è¨€çš„è®¾è®¡ç›®æ ‡ä¹‹ä¸€æ˜¯æä¾›ä¸ C å’Œ C++ ç›¸åª²ç¾çš„æ€§èƒ½ã€‚å®ƒå…·æœ‰é›¶å¼€é”€æŠ½è±¡ã€å†…è”æ±‡ç¼–å’Œå¯¹åº•å±‚ç¡¬ä»¶çš„ç›´æ¥è®¿é—®ç­‰ç‰¹æ€§ï¼Œä½¿å¾—å¼€å‘äººå‘˜èƒ½å¤Ÿç¼–å†™é«˜æ•ˆçš„ç³»ç»Ÿçº§ä»£ç ã€‚ å¯é æ€§ï¼šRust é¼“åŠ±ç¼–å†™å¯é çš„ä»£ç ã€‚å…¶å¼ºåˆ¶çš„æ‰€æœ‰æƒå’Œå€Ÿç”¨è§„åˆ™ä»¥åŠä¸°å¯Œçš„é™æ€ç±»å‹ç³»ç»Ÿå¯ä»¥åœ¨ç¼–è¯‘æ—¶æ•è·æ½œåœ¨çš„é”™è¯¯ï¼Œå‡å°‘è¿è¡Œæ—¶é”™è¯¯çš„å¯èƒ½æ€§ã€‚ ä¸°å¯Œçš„ç¬¬ä¸‰æ–¹åº“æ”¯æŒï¼šRustç”Ÿæ€ç³»ç»Ÿä¸­æœ‰å¤§é‡çš„é«˜è´¨é‡ç¬¬ä¸‰æ–¹åº“ï¼Œå¯ä»¥å¸®åŠ©ç®€åŒ–å†…æ ¸å¼€å‘è¿‡ç¨‹ã€‚ å°½ç®¡Cè¯­è¨€æ˜¯å¹¿æ³›ç”¨äºæ“ä½œç³»ç»Ÿå¼€å‘çš„ä¼ ç»Ÿè¯­è¨€ï¼Œä½† Rust ä½œä¸ºä¸€ç§ç°ä»£ä¸”åˆ›æ–°çš„è¯­è¨€ï¼Œä¸ºå¼€å‘è€…æä¾›äº†æ›´å¥½çš„å·¥å…·å’Œä¿è¯ï¼Œæœ‰åŠ©äºç¼–å†™æ›´å®‰å…¨ã€å¯é å’Œé«˜æ•ˆçš„æ“ä½œç³»ç»Ÿä»£ç ã€‚\nå¼€å‘å†ç¨‹ åœ¨æ¯”èµ›å‡†å¤‡ä¹‹å‰ï¼Œæˆ‘ä»¬çš„å›¢é˜Ÿä¸­çš„åŒå­¦å·²ç»å¯¹ Rust è¯­è¨€æœ‰åˆæ­¥çš„æ¥è§¦ã€‚æ°å¥½åœ¨å­¦ä¹  Rust çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬å‘ç°äº†ä¸€ä¸ªéå¸¸å¥½çš„ Rust å…¥é—¨é¡¹ç›®ï¼Œå³ rCore-Tutorial-v3ã€‚äºæ˜¯æˆ‘ä»¬å‚åŠ äº† rCore-Tutorial çš„æ“ä½œç³»ç»Ÿè®­ç»ƒè¥ã€‚åœ¨å¼€æºç¤¾åŒºçš„æœ‹å‹ä»¬çš„å¸®åŠ©ä¸‹ï¼Œæˆ‘ä»¬å®Œæˆäº†éƒ¨åˆ†å®éªŒï¼Œè¿›ä¸€æ­¥åŠ æ·±äº†å¯¹æ“ä½œç³»ç»ŸåŸºæœ¬åŸç†ä»¥åŠ rCore éƒ¨åˆ†å®ç°ç»†èŠ‚çš„ç†è§£ã€‚\nåœ¨åŒºåŸŸèµ›é˜¶æ®µï¼Œæˆ‘ä»¬å…ˆç®€å•é˜…è¯»äº†éƒ¨åˆ†å¾€å±Šä¼˜ç§€ä½œå“å¦‚ FTL-OS, NPUCore-OS, OopsOS, RongOS, JKXS-OS ç­‰ç­‰ã€‚è™½ç„¶è¿™äº›ä¼˜ç§€ä½œå“ä¸­ï¼Œç‰¹åˆ«æ˜¯è·å¾—äº†å…¨å›½èµ›ä¸€ç­‰å¥–çš„ä½œå“ï¼Œéƒ½æœ‰å„è‡ªä¼˜ç§€çš„ï¼Œç‹¬ç‰¹çš„è®¾è®¡ä¸ä¼˜åŒ–æ–¹æ¡ˆï¼Œä½†è¿™äº›è®¾è®¡ä¸ä¼˜åŒ–å¯¹äºåˆšåˆšä» rCore-Tutorial å­¦ä¹ åçš„æˆ‘ä»¬æ¥è¯´ï¼Œç†è§£èµ·æ¥æ¯”è¾ƒåƒåŠ›ã€‚äºæ˜¯åœ¨ BTD-OS è®¾è®¡åˆæœŸé€‰æ‹©äº†ä¸ rCore-Tutorail è®¾è®¡æ¯”è¾ƒè´´åˆçš„ RongOS ä½œä¸ºå‚è€ƒæ¨¡æ¿ï¼Œç»“åˆ rCore-Tutorial-v3 çš„ ch5 åˆ†æ”¯å¼€å‘ï¼Œå°½å¯èƒ½åœ°ä½¿å†…æ ¸çœ‹èµ·æ¥ç»“æ„æ¸…æ™°ï¼Œç®€æ´å°å·§ã€‚\nåœ¨å…¨å›½èµ›ç¬¬ä¸€é˜¶æ®µï¼Œä¸»è¦å·¥ä½œæ˜¯æ˜¯ç§»æ¤ busybox å®Œå–„å„ä¸ªæµ‹è¯•è¦æ±‚çš„ç³»ç»Ÿè°ƒç”¨ä»¥åŠæ¥å…¥ç¡¬ä»¶è®¾å¤‡ HiFive Unmatched U740 æ¿å¡ã€‚åœ¨è¿™ä¸ªæ—¶æœŸï¼Œæˆ‘ä»¬èŠ±è´¹äº†å¤§é‡çš„æ—¶é—´æ ¹æ® man-page æ–‡æ¡£è¦æ±‚ï¼Œå®Œå–„åˆæœŸè¦æ±‚å®ç°çš„ç³»ç»Ÿè°ƒç”¨ï¼Œæ·»åŠ æ–°çš„ç³»ç»Ÿè°ƒç”¨ï¼Œå¹¶åœ¨å†…æ ¸ä¸­åŠ å…¥è¿™äº›ç³»ç»Ÿè°ƒç”¨è¦æ±‚ç»´æŠ¤çš„æ•°æ®ç»“æ„ï¼Œå‚è€ƒå¾€å±Šä½œå“ä¸­å¯¹ç¡¬ä»¶è®¾å¤‡çš„ç§»æ¤æ–¹æ¡ˆç­‰ç­‰ã€‚åˆ°ç¬¬ä¸€é˜¶æ®µæäº¤æ—¶ï¼Œæˆ‘ä»¬å®Œæˆäº†å¤§éƒ¨åˆ†çš„æµ‹ä¾‹ï¼Œä½†ä»æœ‰éƒ¨åˆ†æµ‹ä¾‹è¦æ±‚çš„ç»“æ„ä¸åŠŸèƒ½ï¼Œå¦‚ç½‘ç»œç­‰ï¼Œåœ¨å†…æ ¸ä¸­è¿˜æœªå®ç°ã€‚å¦å¤–ï¼Œç”±äºåœ¨çº¿ç¡¬ä»¶èµ„æºè¾ƒéš¾è·å–ï¼Œæˆ‘ä»¬æ²¡æœ‰å®Œæˆå¯¹äºç¡¬ä»¶æ¥å…¥çš„è°ƒè¯•ã€‚åŒæ—¶ï¼Œåœ¨QEMUå¹³å°ä¸Šè¿è¡Œæµ‹è¯•æ—¶ï¼Œæˆ‘ä»¬å‘ç°å†…æ ¸çš„æ‰§è¡Œé€Ÿåº¦éå¸¸æ…¢ï¼Œéš¾ä»¥æ¥å—ã€‚äºæ˜¯åœ¨åœ¨å…¨å›½èµ›ç¬¬ä¸€é˜¶æ®µç»“æŸåï¼Œæˆ‘ä»¬é€šè¿‡è‡ªå·±å†™çš„ä¸€äº›å°çš„æ€§èƒ½æµ‹è¯•å·¥å…·ï¼Œå¦‚ time-tracer å‘ç°äº†å†…æ ¸æœ€å¤§çš„æ€§èƒ½é—®é¢˜ â€”â€” å¤§é‡åœ°ç›´æ¥è¯»å†™ FAT32 æ–‡ä»¶ç³»ç»Ÿã€‚\nåœ¨è¿›å…¥å…¨å›½èµ›ç¬¬äºŒé˜¶æ®µå‰ï¼Œæˆ‘ä»¬ä¸»è¦å·¥ä½œåŒ…æ‹¬ï¼šé€šè¿‡å¼•å…¥ PageCache æœºåˆ¶ï¼Œæ”¹è¿› FAT32 è¯»å†™è¿‡ç¨‹ä¸­çš„ç°‡é“¾æŸ¥æ‰¾æ¨¡å¼ä»¥è§£å†³æ–‡ä»¶ç³»ç»Ÿå¯¼è‡´çš„æ€§èƒ½é—®é¢˜ï¼›å®Œå–„å¯¹ç¡¬ä»¶è®¾å¤‡ HiFive Unmatched U740 æ¿å¡çš„æ”¯æŒï¼›æ”¹è¿›å¤šæ ¸çš„æ”¯æŒï¼›å®Œæˆç½‘ç»œè®¾è®¡ç­‰å·¥ä½œã€‚\nå®Œæˆæƒ…å†µ å†…æ ¸æ¨¡å— å®Œæˆæƒ…å†µ ç³»ç»Ÿè°ƒç”¨ è¿›ç¨‹ç®¡ç† åˆ†æ—¶å¤šä»»åŠ¡\nå¤šçº¿ç¨‹\nå¤šæ ¸\nç¬¦åˆ man-page è§„èŒƒçš„ futex æœºåˆ¶ clone, exec, wait4, exit,\nexit_group, getpid, getppid, gettid,\nset_tid_address, clock_gettime,\nkill, tkill, getscheduler\nclock_getres, socketpair,\nset_robust_list, get_robust_list,\nprlimit64 ç­‰ å†…å­˜ç®¡ç† é¡µç¼“å­˜\næ‡’åˆ†é…ä¸å†™æ—¶æ‹·è´\nå…±äº«å†…å­˜ brk, munmap, mmap, shmget,\nshmctl, shmat, shmdt, mprotect æ–‡ä»¶ç³»ç»Ÿ FAT32\nå—ç¼“å­˜\nä¸å†…å­˜é¡µç¼“å­˜ç»“åˆ\nInodeCache getcwd, pipe2, dup, dup3,\nchdir, openat, close, getdents64,\nread, pread64, write, pwrite64,\nunlinkat, mkdirat, ummount2, mount,\nfstat, readv, writev, ioctl,\nfcntl, newfstatat, sendfile,\nutimensat, renameat2, lseek,\nreadlinkat, sync, ftruncate64,\npselect, statfs ç­‰ ä¿¡å·ç³»ç»Ÿ ç¬¦åˆ man-page è§„èŒƒçš„ä¿¡å·å¤„ç†æœºåˆ¶ sigreturn, sigaction, sigprocmask å…¶ä»–ç³»ç»Ÿè°ƒç”¨ times, uname, sched_yield, gettimeofday\nnanosleep, clock_nanosleep, gettrandom,\nsettimer, getittimer, timer_settime,\nrecvfrom ","date":"2023-08-19","permalink":"https://bitethedisk.github.io/post/overview/","tags":["Docs"],"title":"[Docs] æ¦‚è¿°"},{"content":"æˆ‘ä»¬åœ¨ FAT32 è®¾è®¡ä¸Šï¼Œé‡‡ç”¨äº† rCore-Tutorial easy-fs ç›¸åŒçš„æ¾è€¦åˆæ¨¡å—åŒ–è®¾è®¡æ€è·¯ï¼Œä¸åº•å±‚è®¾å¤‡é©±åŠ¨ä¹‹é—´é€šè¿‡æŠ½è±¡æ¥å£ BlockDevice æ¥è¿æ¥ï¼Œé¿å…äº†ä¸è®¾å¤‡é©±åŠ¨çš„ç»‘å®šã€‚FAT32 åº“é€šè¿‡ Rust æä¾›çš„ alloc crate æ¥éš”ç¦»äº†æ“ä½œç³»ç»Ÿå†…æ ¸çš„å†…å­˜ç®¡ç†ï¼Œé¿å…äº†ç›´æ¥è°ƒç”¨å†…å­˜ç®¡ç†çš„å†…æ ¸å‡½æ•°ã€‚ åŒæ—¶åœ¨è®¾è®¡ä¸­é¿å…äº†ç›´æ¥è®¿é—®è¿›ç¨‹ç›¸å…³çš„æ•°æ®å’Œå‡½æ•°ï¼Œä»è€Œéš”ç¦»äº†æ“ä½œç³»ç»Ÿå†…æ ¸çš„è¿›ç¨‹ç®¡ç†ã€‚\nè™½ç„¶æˆ‘ä»¬åœ¨å†…æ ¸ä¸­ç»™å‡ºäº†è™šæ‹Ÿæ–‡ä»¶çš„æŠ½è±¡ File Traitï¼Œä½†æ˜¯ç”±äºåªå®Œæˆçš„ FAT32 æ–‡ä»¶ç³»ç»Ÿï¼Œå†…æ ¸ä¸­ä¸å­˜åœ¨è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿè¿™ä¸€æŠ½è±¡ï¼Œä¹Ÿæ²¡æœ‰ Inode å±‚é¢çš„ç¼“å­˜ï¼Œå†…æ ¸ä¸­çš„æ–‡ä»¶å®é™…ä¸Šå°† FAT32 æä¾›çš„ VirtFile è¿›ä¸€æ­¥å°è£…æˆ KFileï¼Œè¿™å¯¼è‡´æ¯æ¬¡å†™å…¥æ•°æ®éƒ½ä¼šåŒæ­¥åˆ°ç£ç›˜ï¼Œæ­¤æ—¶ BlockCache ç¼“å­˜å—çš„ä½œç”¨å¾®ä¹å…¶å¾®ã€‚\nç¬¬ä¸€é˜¶æ®µ â€”â€” Static BusyBox åœ¨å…¨å›½èµ›ç¬¬ä¸€é˜¶æ®µæ—¶ï¼Œæˆ‘ä»¬åœ¨æµ‹è¯•è¿‡ç¨‹ä¸­å‘ç°å†…æ ¸è·‘æµ‹ä¾‹çš„æ‰§è¡Œé€Ÿåº¦éå¸¸ç¼“æ…¢ï¼Œ æ¯”å¦‚å¯åŠ¨ busybox éƒ½éœ€è¦èŠ±åŠåˆ†é’Ÿã€iozone æµ‹è¯•ä¸­ï¼Œè¯»å†™é€Ÿåº¦å¤§æ¦‚ä¸ºå‡ ååˆ°å‡ ç™¾ KB/sï¼Œæ˜¾ç„¶å†…æ ¸çš„æ–‡ä»¶è¯»å†™æ€§èƒ½éå¸¸ç³Ÿç³•ï¼Œå¯¼è‡´æ²¡æ³•è·‘å®Œæˆ‘ä»¬å·²ç»å®ç°çš„æµ‹è¯•ã€‚\næ­¤æ—¶ä¸ºäº†å°½å¯èƒ½è·‘å®Œæµ‹è¯•ï¼Œæˆ‘ä»¬å‘ç°ç”±äºå¤§éƒ¨åˆ†æµ‹è¯•éœ€è¦ä½¿ç”¨ busyboxï¼Œä¸ºäº†é¿å…å¤šæ¬¡è§£æ elfã€ ä»é›¶åˆ›å»ºåœ°å€ç©ºé—´ç­‰é—®é¢˜ï¼Œæˆ‘ä»¬é‡‡ç”¨äº†ç±»ä¼¼äºåŠ è½½ initproc çš„æ–¹æ³•ã€‚ å…·ä½“è€Œè¨€ï¼Œæˆ‘ä»¬å°† busybox é¢„åŠ è½½åˆ°å†…æ ¸ä¸­ï¼Œå¹¶ä¿å­˜ load_elf è·å–çš„ä¿¡æ¯ã€‚æ¯æ¬¡æ‰§è¡Œ busybox æ—¶ï¼Œ æˆ‘ä»¬ç›´æ¥ä½¿ç”¨ä¿å­˜çš„ load_elf ä¿¡æ¯ï¼Œå¹¶é€šè¿‡å†™æ—¶æ‹·è´æ¥åˆ›å»ºæ‰€éœ€çš„ busybox è¿›ç¨‹çš„åœ°å€ç©ºé—´ï¼Œæ›´å¿«é€Ÿåœ°åˆ›å»º busyboxã€‚\n// ç¬¬ä¸€é˜¶æ®µ submit åˆ†æ”¯ pub static ref BUSYBOX: RwLock\u0026lt;Busybox\u0026gt; = RwLock::new({ extern \u0026quot;C\u0026quot; { fn busybox_entry(); fn busybox_tail(); } let entry = busybox_entry as usize; let tail = busybox_tail as usize; let siz = tail - entry; let busybox = unsafe { core::slice::from_raw_parts(entry as *const u8, siz) }; let path = AbsolutePath::from_str(\u0026quot;/busybox0\u0026quot;); let inode = fs::open(path, OpenFlags::O_CREATE, CreateMode::empty()).expect(\u0026quot;busybox0 create failed\u0026quot;); inode.write_all(\u0026amp;busybox.to_owned()); let bb = Arc::new(TaskControlBlock::new(inode.clone())); inode.delete(); Busybox { inner: bb, } }); pub static mut ONCE_BB_ENTRY: usize = 0; pub static mut ONCE_BB_AUX: Vec\u0026lt;AuxEntry\u0026gt; = Vec::new(); pub struct Busybox { inner: Arc\u0026lt;TaskControlBlock\u0026gt;, } impl Busybox { pub fn elf_entry_point(\u0026amp;self) -\u0026gt; usize { unsafe { ONCE_BB_ENTRY } } pub fn aux(\u0026amp;self) -\u0026gt; Vec\u0026lt;AuxEntry\u0026gt; { unsafe { ONCE_BB_AUX.clone() } } pub fn memory_set(\u0026amp;self) -\u0026gt; MemorySet { let mut write = self.inner.memory_set.write(); MemorySet::from_copy_on_write(\u0026amp;mut write) } } è™½ç„¶å¯¹äºå½“æ—¶çš„æˆ‘ä»¬æ¥è¯´ç®—æ˜¯é›ªä¸­é€ç‚­ã€‚ä½†è¿™å®é™…ä¸Šå¹¶éåˆç†çš„è®¾è®¡ã€‚\nç¬¬ä¸€é˜¶æ®µå â€”â€” åˆ†æ FAT32ï¼Œæ”¹é€ ç°‡é“¾ åœ¨ç¬¬ä¸€é˜¶æ®µç»“æŸåï¼Œæˆ‘ä»¬é€šè¿‡è¿½è¸ªè¯»å†™ç›¸å…³ä»£ç æ‰€è€—è´¹çš„æ—¶é—´, æ¯”å¦‚ï¼š\n// å½“å‰ pub fn write_at(\u0026amp;self, offset: usize, buf: \u0026amp;[u8]) -\u0026gt; usize { #[cfg(feature = \u0026quot;time-tracer\u0026quot;)] time_trace!(\u0026quot;write_at\u0026quot;); ... } pub fn read_at(\u0026amp;self, offset: usize, buf: \u0026amp;mut [u8]) -\u0026gt; usize { #[cfg(feature = \u0026quot;time-tracer\u0026quot;)] time_trace!(\u0026quot;read_at\u0026quot;); } #[cfg(feature = \u0026quot;time-tracer\u0026quot;)] start_trace!(\u0026quot;cluster\u0026quot;); let pre_cluster_cnt = offset / cluster_size; #[cfg(feature = \u0026quot;time-tracer\u0026quot;)] start_trace!(\u0026quot;clone\u0026quot;); let clus_chain = self.cluster_chain.read(); #[cfg(feature = \u0026quot;time-tracer\u0026quot;)] end_trace!(); let mut cluster_iter = clus_chain.cluster_vec.iter().skip(pre_cluster_cnt); #[cfg(feature = \u0026quot;time-tracer\u0026quot;)] end_trace!(); (TimeTracer ç”¨äºè®°å½•æ‰§è¡Œåˆ°å½“å‰ä»£ç çš„æ—¶çš„ç³»ç»Ÿæ—¶é—´, å½“ Timetracer drop æ—¶ç»Ÿè®¡æœŸé—´æ¶ˆè€—çš„æ—¶é—´)\né¦–å…ˆå®šä½åˆ°å½±å“ FAT32 æ–‡ä»¶ç›´æ¥è¯»å†™æ–‡ä»¶è¿‡ç¨‹ä¸­æœ€ä¸ºè€—æ—¶çš„æ“ä½œï¼šéå†æ–‡ä»¶çš„ç°‡é“¾è¿‡ç¨‹ä¸­ï¼Œä¸æ–­åœ¨ FAT è¡¨ä¸­æŸ¥è¯¢ä¸‹ä¸€ç°‡çš„ä½ç½®ã€‚æˆ‘ä»¬å®ç°çš„ FAT32 æ–‡ä»¶ç³»ç»Ÿæ‰€æœ‰è¯»å†™ï¼ŒåŒ…æ‹¬éå†ç°‡é“¾çš„æ“ä½œéƒ½æ˜¯ä¾èµ– BlockCache æä¾›çš„ get_block_cache æ–¹æ³•ï¼Œä½†å…¶ä¸­éå†ç°‡é“¾è¿™ä¸ªæ“ä½œéå¸¸çš„é¢‘ç¹ï¼Œå¯¼è‡´æ•´ä¸ªè¯»å†™è¿‡ç¨‹è€—æ—¶ä¸¥é‡ã€‚\nè¯»å†™æ–‡ä»¶æ—¶ï¼š\n// ç¬¬ä¸€é˜¶æ®µ submit åˆ†æ”¯ while index \u0026lt; end { let cluster_offset_in_disk = self.fs.read().bpb.offset(curr_cluster); let start_block_id = cluster_offset_in_disk / BLOCK_SIZE; for block_id in start_block_id..start_block_id + spc { ... } if index \u0026gt;= end { break; } curr_cluster = self.fs.read() .fat.read() .get_next_cluster(curr_cluster).unwrap(); curr_cluster = clus_chain.current_cluster; } // ç¬¬ä¸€é˜¶æ®µ submit åˆ†æ”¯ pub fn get_next_cluster(\u0026amp;self, cluster: u32) -\u0026gt; Option\u0026lt;u32\u0026gt; { let (block_id, offset_in_block) = self.cluster_id_pos(cluster); let next_cluster: u32 = get_block_cache(block_id, Arc::clone(\u0026amp;self.device)) .read() .read(offset_in_block, |\u0026amp;next_cluster: \u0026amp;u32| next_cluster); assert!(next_cluster \u0026gt;= 2); if next_cluster \u0026gt;= END_OF_CLUSTER { None } else { Some(next_cluster) } } åŸºæœ¬æµç¨‹ä¸ºï¼šIMAGE\nç”±äºè¯¥æ“ä½œå¯¹äºåŒä¸€æ–‡ä»¶çš„è¯»å†™éå¸¸é¢‘ç¹ï¼Œå¹¶ä¸”å¤§éƒ¨åˆ†æƒ…å†µä¸‹ï¼Œç‰¹åˆ«æ˜¯å¤šæ¬¡è¯»æ–‡ä»¶æ—¶ï¼Œæ‰€è·å–çš„ç°‡é“¾ä¿¡æ¯ä¸å˜ï¼Œä½†æ¯æ¬¡éƒ½è¦é‡æ–°ä» BlockCache ä¸­è¯»å–ï¼Œæ˜¾ç„¶è¿™ä¸ªè¿‡ç¨‹æ˜¯å¯ä»¥ä¼˜åŒ–çš„ã€‚ä¸€ä¸ªéå¸¸å®¹æ˜“æƒ³åˆ°çš„æ–¹æ³•å°±æ˜¯ï¼š\nåœ¨æ‰“å¼€æ–‡ä»¶æ—¶ï¼Œé¢„è¯»ç°‡é“¾ï¼Œå°†ç°‡é“¾ä¿¡æ¯ä¿å­˜ä¸‹æ¥ å¯¹äºå¯èƒ½ä¼šä¿®æ”¹ç°‡é“¾çš„æ–‡ä»¶å†™æ“ä½œï¼Œå¦‚åœ¨æ–‡ä»¶ increase_size æ—¶ï¼Œé‡æ–°è¯»å–ç°‡é“¾ äºæ˜¯æˆ‘ä»¬å¯¹ FAT32 æ–‡ä»¶ç³»ç»Ÿçš„ç°‡é“¾è®¾è®¡åšå‡ºä¿®æ”¹ï¼š\n// å½“å‰ pub struct ClusterChain { ... pub(crate) cluster_vec: Vec\u0026lt;u32\u0026gt;, } // å½“å‰ // open / increase_size æ—¶ loop { ... let next_cluster = get_block_cache(block_id, Arc::clone(\u0026amp;self.device)) .read() .read(offset_left, |\u0026amp;cluster: \u0026amp;u32| cluster); if next_cluster \u0026gt;= END_OF_CLUSTER { break; } else { self.cluster_vec.push(next_cluster); }; } å¯¹æ¯”è§†é¢‘ï¼šIMAGE\nç¬¬ä¸€é˜¶æ®µå â€”â€” æ›´è¿›ä¸€æ­¥ï¼ŒPage Cache å…¶å®ç»è¿‡ä»¥ä¸Šä¼˜åŒ–ï¼Œå†…æ ¸è¿è¡Œæµ‹è¯•æ—¶çš„é€Ÿåº¦å·²ç»èƒ½å¤Ÿæ¥å—äº†ã€‚ä½†æ˜¯é—®é¢˜çš„å…³é”®è¿˜æ˜¯åœ¨äºä¸Šé¢æåˆ°çš„ï¼šç”±äºåªå®Œæˆçš„ FAT32 æ–‡ä»¶ç³»ç»Ÿï¼Œå†…æ ¸ä¸­ä¸å­˜åœ¨è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿè¿™ä¸€æŠ½è±¡ï¼Œä¹Ÿæ²¡æœ‰ Inode å±‚é¢çš„ç¼“å­˜ï¼Œå†…æ ¸ä¸­çš„æ–‡ä»¶å®é™…ä¸Šå°† FAT32 æä¾›çš„ VirtFile è¿›ä¸€æ­¥å°è£…æˆ KFileï¼Œè¿™å¯¼è‡´æ¯æ¬¡å†™å…¥æ•°æ®éƒ½ä¼šåŒæ­¥åˆ°ç£ç›˜ã€‚\næ–‡ä»¶è¯»å†™æ—¶ï¼Œå¤§é‡çš„ç£ç›˜ç›´æ¥ IOï¼Œæ‰æ˜¯æ€¥éœ€è§£å†³çš„é—®é¢˜ã€‚ç”±äºæµ‹è¯•è¿‡ç¨‹ä¸­åˆ›å»ºçš„æ–‡ä»¶çš„è¯»å†™æ“ä½œå®é™…ä¸Šæ˜¯åœ¨å†…å­˜ä¸­é€šè¿‡ Page Cache è¿›è¡Œçš„ï¼Œå¾€å¾€ä¸ä¼šç›´æ¥å†™å›æ–‡ä»¶ç³»ç»Ÿï¼Œç‰¹åˆ«æ˜¯åœ¨å•æ ¸ä¸‹ï¼Œå¤§é‡çš„å¯¹ç£ç›˜çš„ç›´æ¥è¯»å†™ä¼šå¯¼è‡´å†…æ ¸æ‰§è¡Œé€Ÿåº¦å˜æ…¢ï¼ˆå®é™…æˆ‘ä»¬åœ¨å¤šæ ¸ä¸‹æµ‹è¯•å¼€å¯å†™å›æ“ä½œå¯¹é€Ÿåº¦å½±å“ä¸å¤§ï¼‰ã€‚\næˆ‘ä»¬é¦–å…ˆæƒ³åˆ°äº†å¯ä»¥é€šè¿‡å®ç° TempFS (å°†æ–‡ä»¶å­˜å‚¨åœ¨ç³»ç»Ÿçš„å†…å­˜ä¸­è€Œä¸æ˜¯ç£ç›˜ä¸Š)ï¼Œå°†æµ‹è¯•è¿‡ç¨‹ä¸­å†…æ ¸å…³äºæ–‡ä»¶çš„æ“ä½œå¦‚åˆ›å»ºï¼Œè¯»å†™ç­‰ï¼Œéƒ½äº¤ç»™ TempFSï¼Œä¸å¿…æ¯æ¬¡éƒ½å†™å› FAT32ã€‚æˆ–è€…æ˜¯åœ¨ç›®å‰çš„ KFile åŸºç¡€ä¸ŠåŠ ä¸Š PageCache å‡å°‘å¯¹ç£ç›˜çš„é¢‘ç¹è®¿é—®ã€‚\nç”±äºç¼ºä¹ç›¸å…³å®ç°ç»éªŒï¼ŒæŸ¥çœ‹äº†éƒ¨åˆ†ç¬¬ä¸€é˜¶æ®µæäº¤æ—¶çš„ä¼˜ç§€é˜Ÿä¼çš„æ˜¯å¦æœ‰åšç›¸å…³å·¥ä½œï¼Œå¸Œæœ›ä»ä¸­å­¦åˆ°å®ç°æ€è·¯ã€‚\næœ€åæˆ‘ä»¬é€‰æ‹©å‚è€ƒåŒä¸€æœŸçš„ä¼˜ç§€é˜Ÿä¼ TitanixOS çš„ PageCache å®ç°æ€è·¯ï¼Œä¸ºå†…æ ¸åŠ å…¥ PageCache æœºåˆ¶ã€‚\nç›¸å…³ç»“æ„å¦‚ä¸‹ï¼š\npub struct KFile { // read only feilds readable: bool, writable: bool, path: AbsolutePath, name: String, // shared by some files (uaually happens when fork) pub time_info: Mutex\u0026lt;InodeTime\u0026gt;, pub offset: Mutex\u0026lt;usize\u0026gt;, pub flags: Mutex\u0026lt;OpenFlags\u0026gt;, pub available: Mutex\u0026lt;bool\u0026gt;, // shared by the same file (with page cache) pub inode: Arc\u0026lt;Inode\u0026gt;, } pub struct Inode { pub file: Mutex\u0026lt;Arc\u0026lt;VirtFile\u0026gt;\u0026gt;, fid: u64, #[cfg(not(feature = \u0026quot;no-page-cache\u0026quot;))] pub page_cache: Mutex\u0026lt;Option\u0026lt;Arc\u0026lt;PageCache\u0026gt;\u0026gt;\u0026gt;, #[cfg(not(feature = \u0026quot;no-page-cache\u0026quot;))] pub file_size: Mutex\u0026lt;usize\u0026gt;, } å…³äº Inode çš„è®¾è®¡ï¼š\né…åˆ InodeCache åŠ å¿«æŸ¥æ‰¾æ•ˆç‡ï¼Œå®ç°æ–‡ä»¶çš„ç¼“å­˜ file å­—æ®µä¸º FAT32 æä¾›çš„ VirtFile å…³äºåœ¨ Inode ä¸­ä¿å­˜æ–‡ä»¶çš„å¤§å°çš„ç†ç”±: æµ‹è¯•è¿‡ç¨‹ä¸­åˆ›å»ºçš„æ–‡ä»¶çš„è¯»å†™æ“ä½œå®é™…ä¸Šæ˜¯åœ¨å†…å­˜ä¸­é€šè¿‡ Page Cache è¿›è¡Œçš„ï¼Œå¾€å¾€ä¸ä¼šç›´æ¥å†™å›æ–‡ä»¶ç³»ç»Ÿã€‚ä¸ºäº†æé«˜æµ‹è¯•é€Ÿåº¦ï¼Œæˆ‘ä»¬ä½¿ç”¨ Rust Feature æœºåˆ¶ï¼Œé»˜è®¤å…³é—­ Inode Drop æ—¶çš„å†™å›æ“ä½œï¼Œç›¸å½“äºå€ŸåŠ© FAT32 VirtFile çš„ â€å¤–å£³â€œ å®ç°äº†ä¸€ä¸ªä¸ç®—æ ‡å‡†çš„ TempFSï¼› æ–‡ä»¶è¯»å†™è¿‡ç¨‹ä¸­éœ€è¦ç”¨åˆ° file_size å‚æ•°ï¼ŒåŠ ä¸Šä¸ä¼šæ¯æ¬¡å†™æ–‡ä»¶æˆ–å…³é—­æ–‡ä»¶åç›´æ¥å†™å›æ–‡ä»¶ç³»ç»Ÿï¼Œ æ•…ä¸èƒ½é€šè¿‡åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­è¯»å–æ–‡ä»¶å¤§å°çš„æ–¹å¼æ¥è·å–æ–‡ä»¶å¤§å°ï¼ˆä¸ä¸€è‡´ï¼‰ï¼› ä¸åŒè¿›ç¨‹å¯¹è¯¥æ–‡ä»¶è¿›è¡Œå†™æ“ä½œæ—¶ä¼šæ”¹å†™æ–‡ä»¶çš„å¤§å°ï¼Œä½¿ç”¨ Inode Cache å†æ¬¡æ‰“å¼€æ–‡ä»¶æ—¶å¿…é¡»ä¿è¯æ–‡ä»¶å¤§å°çš„ä¸€è‡´æ€§ã€‚ pub struct PageCache { inode: Option\u0026lt;Weak\u0026lt;VirtFile\u0026gt;\u0026gt;, // page number -\u0026gt; page pub pages: RwLock\u0026lt;BTreeMap\u0026lt;usize, Arc\u0026lt;FilePage\u0026gt;\u0026gt;\u0026gt;, } pub struct FilePage { pub permission: MapPermission, pub data_frame: FrameTracker, pub file_info: Option\u0026lt;Mutex\u0026lt;FilePageInfo\u0026gt;\u0026gt;, } pub struct FilePageInfo { /// é¡µçš„èµ·å§‹ä½ç½®åœ¨æ–‡ä»¶ä¸­çš„åç§»ï¼ˆä¸€å®šæ˜¯é¡µå¯¹é½çš„ï¼‰ pub file_offset: usize, pub data_states: [DataState; PAGE_SIZE / BLOCK_SIZE], inode: Weak\u0026lt;VirtFile\u0026gt;, } æ–‡ä»¶æ“ä½œå›¾ç‰‡ï¼šIMG\nå¯¹æ¯”å›¾ç‰‡ï¼šIMG\nè‡³æ­¤ï¼Œæˆ‘ä»¬çš„å†…æ ¸æ–‡ä»¶ä¼˜åŒ–è¿‡ç¨‹æš‚æ—¶å‘Šä¸€æ®µè½ã€‚\n","date":"2023-08-17","permalink":"https://bitethedisk.github.io/post/fs-optimization/","tags":["ä¼˜åŒ–"],"title":"æ–‡ä»¶ç³»ç»Ÿä¼˜åŒ–å†ç¨‹"},{"content":"å®ç°åŠ¨æ€è¿æ¥ååˆ†ç®€å•ï¼Œåªéœ€è¦åœ¨åŠ è½½elfæ–‡ä»¶æ—¶åˆ¤æ–­æ˜¯å¦å­˜åœ¨interpretæ®µï¼Œå¦‚æœå­˜åœ¨å°±åŠ è½½å¯¹åº”çš„åŠ¨æ€è¿æ¥å™¨ï¼Œ å°†åŠ¨æ€è¿æ¥å™¨å†…å®¹æ˜ å°„è¿›å†…å­˜å¹¶å°†ç¨‹åºå…¥å£è®¾ç½®ä¸ºåŠ¨æ€è¿æ¥å™¨çš„å…¥å£ã€‚æ¥ä¸‹æ¥åŠ¨æ€è¿æ¥å™¨ä¼šå®Œæˆå‰©ä¸‹çš„è¿æ¥å·¥ä½œã€‚\nå°½ç®¡åŸç†å¾ˆç®€å•ï¼Œä½†ç”±äºåŠ¨æ€è¿æ¥æ¶‰åŠçš„ç³»ç»Ÿè°ƒç”¨è¾ƒå¤šï¼Œåœ¨åŠ å…¥åŠ¨æ€è¿æ¥åå¾ˆå®¹æ˜“å‡ºbugã€‚ æœªæ­£ç¡®å¤„ç†mmapï¼Œæ²¡å‹å…¥æˆ–å‹å…¥äº†é”™è¯¯çš„auxæ•°ç»„ï¼Œfstatè¿”å›ç©ºç»“æ„ä½“éƒ½å¯èƒ½å¯¼è‡´åŠ¨æ€è¿æ¥å¤±è´¥ã€‚ å€¼å¾—ä¸€æçš„æ˜¯ï¼Œè¿™é‡Œä½¿ç”¨çš„åŠ¨æ€è¿æ¥å™¨æ˜¯musl libcï¼Œå®ƒæ—¢æ˜¯åŠ¨æ€è¿æ¥å™¨åˆæ˜¯å‡½æ•°åº“ï¼Œ æµ‹ä¾‹ä¸­ä½¿ç”¨çš„å‡½æ•°ä»¥åŠåŠ¨æ€è¿æ¥çš„è¿‡ç¨‹éƒ½å¯ä»¥ä»è¿™ä¸ªåº“çš„ä»£ç ä¸­æ‰¾åˆ°ã€‚é˜…è¯»è¿™éƒ¨åˆ†ä»£ç ä¼šå¯¹è°ƒè¯•ç¨‹åºæœ‰å¸®åŠ©ã€‚\n","date":"2023-08-01","permalink":"https://bitethedisk.github.io/post/dynamic/","tags":["å…¨å›½èµ›ç¬¬ä¸€é˜¶æ®µ"],"title":"åŠ¨æ€é“¾æ¥"},{"content":"åœ¨ Rust ä¸­ï¼Œå­—ç¬¦ä¸²æ˜¯ä¸€ä¸ªèƒ–æŒ‡é’ˆï¼ŒåŒ…æ‹¬å…·æœ‰æ‰€æœ‰æƒçš„ String ä»¥åŠ \u0026amp;'a strï¼Œå¹¶ä¸”ä¸º utf-8 ç¼–ç \nè€Œåœ¨ C ä¸­ï¼Œå­—ç¬¦ä¸²åªæ˜¯ä¸€ä¸ªå•çº¯çš„æŒ‡é’ˆï¼Œä»¥æœ‰ç¬¦å·çš„ i8 ä¸ºå•å…ƒï¼Œä»¥ \\0 ä½œä¸ºç»“å°¾ï¼Œé•¿åº¦ä¸åŒ…æ‹¬ç»“å°¾ \u0026lsquo;\\0\u0026rsquo;\nåœ¨ä½¿ç”¨ Rust ç¼–å†™ initrpoc å’Œ ç³»ç»Ÿè°ƒç”¨çš„æ—¶å€™ï¼Œç”±äºæµ‹ä¾‹æ‰€è¦æ±‚çš„çš„æ¥å£æ‰€ä½¿ç”¨çš„çš„å­—ç¬¦ä¸²ç›¸å…³å‚æ•°å‡ä¸º C æ ‡å‡†ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦å°† Rust å’Œ C ä¹‹é—´çš„å­—ç¬¦ä¸²è¿›è¡Œè½¬æ¢\nCString Rust ä¸­æä¾›äº† alloc::ffi:CString æ¥å¤„ç†ä¸¤è€…ä¹‹é—´çš„è½¬æ¢\nåˆ›å»º CString ä¸€èˆ¬å¯ä»¥é€šè¿‡ CString::new æ¥åˆ›å»ºä¸€ä¸ª CString\npub fn new\u0026lt;T: Into\u0026lt;Vec\u0026lt;u8\u0026gt;\u0026gt;\u0026gt;(t: T) -\u0026gt; Result\u0026lt;CString, NulError\u0026gt; å…·ä½“å¦‚ä¸‹:\n#[macro_use] extern crate alloc; use alloc::ffi::CString; fn main() { let c_string = CString::new(\u0026quot;Hello, world!\u0026quot;).unwrap(); // ... } è¿™é‡Œçš„ new æ–¹æ³•ä¼šæ£€æŸ¥ä¼ å…¥çš„å€¼æ˜¯å¦æ˜¯ä»¥ \\0 ç»“å°¾çš„ï¼Œè¯¥æ–¹æ³•æœ¬èº«ä¼šå°†ä¼ å…¥çš„å€¼è‡ªåŠ¨åŠ ä¸Š \\0ï¼Œæ‰€ä»¥è¦æ±‚ä¼ å…¥çš„å‚æ•°æ‰€è¡¨ç¤ºçš„å­—ç¬¦ä¸²ä¸èƒ½ä»¥ \\0 ç»“å°¾\nä¹Ÿå¯ä»¥é€šè¿‡ unsafe æ–¹æ³• CString::from_vec_unchecked ç­‰å¿½ç•¥è¿™ç§æ£€æŸ¥\nCString è½¬æ¢éœ€æ³¨æ„ Rust æ˜¯ä¸€é—¨å¼ºè°ƒå®‰å…¨çš„è¯­è¨€ï¼Œæ‰€æœ‰çš„å€¼éƒ½éœ€è¦åœ¨è¶…å‡ºå„è‡ªçš„å£°æ˜å‘¨æœŸåé‡Šæ”¾å…¶æ‰€å æœ‰çš„å†…å­˜\næ–‡æ¡£ä¸­æä¾›äº†ä¸€ä¸ª pub fn into_raw(self) -\u0026gt; *mut c_char æ–¹æ³•ï¼Œè¯¥æ–¹æ³•çš„å®é™…æ„ä¹‰å’Œå®ƒçš„ç­¾åå¹¶ä¸ç›¸åŒ: å…¶è¿”å›çš„å­—ç¬¦ä¸²å¿…é¡»ä¸å¯å˜ï¼\nå› ä¸ºä» Rust å‘ C ä¼ é€’çš„å­—ç¬¦ä¸²æœ¬è´¨ä¸Šè¿˜æ˜¯å½“å‰ Rust ç¨‹åºåˆ†é…çš„å†…å­˜(åœ¨å †ä¸Šï¼Œæœ¬è´¨è¿˜æ˜¯ä¸€ä¸ª Vec\u0026lt;u8\u0026gt;ï¼Œå¯¹ï¼Œæ˜¯ u8ï¼Œè€Œä¸æ˜¯ i8ï¼Œä¼°è®¡æ˜¯ä¸ºäº†é˜²æ­¢ç”±äºæº¢å‡ºè€Œå¯¼è‡´çš„ç¼–è¯‘å¤±è´¥ï¼Œrustc dddd)ï¼Œå¦‚æœåœ¨ C ç¨‹åºä¸­æ”¹å˜äº†å½“å‰å­—ç¬¦ä¸²çš„å€¼ï¼Œæ¯”å¦‚åˆ å»ç»“å°¾ \\0ï¼Œæˆ–è€…å°† \\0 æå‰ï¼Œéƒ½ä¼šå¸¦æ¥å†…å­˜å®‰å…¨éšæ‚£\næ‰€ä»¥ï¼Œè¿™é‡Œçš„ *mut c_char å®é™…å¯¹åº” C ä¸­çš„ char *\nåŠæ—¶å›æ”¶ CString é˜²æ­¢å†…å­˜æ³„éœ² å‰é¢æåˆ°ï¼ŒCString åº•å±‚å…¶å®æ˜¯ Vec\u0026lt;u8\u0026gt;ï¼Œå…¶å®é™…ä¸Šæ˜¯åˆ†é…åœ¨ Rust çš„å †ä¸Šçš„\nåœ¨å°† CString leek æˆä¼ ç»™ C çš„æŒ‡é’ˆåï¼ŒCString åº•å±‚çš„ Vec\u0026lt;u8\u0026gt; å°±è„±ç¦»äº† Rust æ‰€æœ‰æƒæœºåˆ¶çš„ç›‘ç®¡ï¼Œå¦‚æœä¸é‡æ„è£¸æŒ‡é’ˆçš„æ‰€æœ‰æƒï¼Œé‚£å°†ä¼šå¯¼è‡´å†…å­˜æ³„éœ²\nè¦æƒ³å›æ”¶ CString æ‰€ä½¿ç”¨çš„å†…å­˜ï¼Œå¯ä»¥æŒ‰ä»¥ä¸‹æ“ä½œ\n#[macro_use] extern crate alloc; use alloc::ffi::CString; fn main() { let initproc = CString::new(\u0026quot;/busybox\u0026quot;).unwrap(); let initproc_raw = initproc.into_raw(); // ... // Execute syscall, which uses C ABI. execve(iniproc, /* argv, envs */); // Release memory of `initproc_raw`. { unsafe { CString::from_raw(initproc_raw); } } } ","date":"2023-08-01","permalink":"https://bitethedisk.github.io/post/rust-and-c/","tags":["å…¨å›½èµ›ç¬¬ä¸€é˜¶æ®µ","FFI"],"title":"Rust å’Œ C çš„äº¤äº’"},{"content":"åœ¨ç›®å‰çš„å®ç°ä¸­ä¿¡å·æ€»å…±æœ‰63ç§ï¼Œ1-31ä¸ºéå®æ—¶ä¿¡å·ï¼Œ34-63æ˜¯å®æ—¶ä¿¡å·ã€‚32å’Œ33ä¸ºæœªå®šä¹‰ä¿¡å·ã€‚ ä¿¡å·æ˜¯æ¯ä¸ªè¿›ç¨‹ç‹¬æœ‰çš„ï¼Œé™¤æ­¤ä¹‹å¤–æ¯ä¸ªè¿›ç¨‹è¿˜æœ‰ä¿¡å·æ©ç ã€‚\næ¶‰åŠä¿¡å·å¤„ç†çš„å…±æœ‰3ä¸ªç³»ç»Ÿè°ƒç”¨ï¼šSYS_SIGACTIONï¼ŒSYS_SIGPROCMASKï¼ŒSYS_SIGRETURNã€‚\næ¶‰åŠçš„ç³»ç»Ÿè°ƒç”¨ sys_sigactionç”¨äºä¸ºä¸€ä¸ªä¿¡å·æ³¨å†Œä¿¡å·å¤„ç†å‡½æ•°ï¼Œå½“è¿›ç¨‹æ¥å—åˆ°ä¿¡å·åä¼šè·³è½¬åˆ°è¿™ä¸ªä¿¡å·å¤„ç†å‡½æ•°ã€‚ ä¸€èˆ¬ä¿¡å·å¤„ç†å‡½æ•°åä¼šè°ƒç”¨sigreturnå°†ç¨‹åºä¸Šä¸‹æ–‡æ¢å¤åˆ°æ‰§è¡Œä¿¡å·å¤„ç†å‡½æ•°ä¹‹å‰çš„çŠ¶æ€ã€‚ ä½†ç¨‹åºä¹Ÿå¯èƒ½ä¸è°ƒç”¨sigreturnï¼Œè€Œæ˜¯ä½¿ç”¨longjumpè·³è½¬åˆ°åˆ«çš„ä½ç½®ï¼Œå†…æ ¸ä¸å…³å¿ƒä¿¡å·å¤„ç†å‡½æ•°æ˜¯å¦è¿”å›ï¼Œ ä¸åœ¨å†…æ ¸ä¸­ç»´æŠ¤ä¿¡å·å¤„ç†ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œè€Œæ˜¯åœ¨æ‰§è¡Œä¿¡å·å¤„ç†å‡½æ•°ä¹‹å‰å°†ä¸Šä¸‹æ–‡å‹å…¥ç”¨æˆ·æ ˆï¼Œå¹¶åœ¨sigreturnæ—¶ä»ç”¨æˆ·æ ˆä¸­æ¢å¤ä¿¡æ¯ã€‚ åœ¨æ‰§è¡Œä¿¡å·å¤„ç†å‡½æ•°çš„è¿‡ç¨‹ä¸­ï¼Œè¿™äº›ä¿å­˜çš„ä¸Šä¸‹æ–‡ä¿¡æ¯å¯èƒ½è¢«ç”¨æˆ·ç¨‹åºä¿®æ”¹ï¼Œç”¨æˆ·ç¨‹åºå¯ä»¥å€Ÿæ­¤è¿”å›åˆ°ä¸åŒçš„åœ°æ–¹ã€‚\nsys_sigprocmaskç”¨äºä¿®æ”¹è¿›ç¨‹çš„ä¿¡å·æ©ç ã€‚ä¿¡å·æ©ç å¯ä»¥ç”¨æ¥å±è”½ä¿¡å·ï¼Œè¢«å±è”½çš„ä¿¡å·ä¼šè¢«é˜»å¡ï¼Œ ç›´åˆ°ä¿¡å·æ©ç ä¸å†é˜»å¡è¯¥ä¿¡å·æ—¶è¯¥ä¿¡å·æ‰ä¼šè¢«å¤„ç†ã€‚ 9å·ä¿¡å·å’Œ19å·ä¿¡å·ä¸èƒ½è¢«é˜»å¡ã€‚ sys_sigreturnä¼šä»ç”¨æˆ·æ ˆä¸­å–å‡ºä¸Šä¸‹æ–‡ä¿¡æ¯å°†ç¨‹åºæ¢å¤åˆ°ä¿¡å·å¤„ç†å‰çš„çŠ¶æ€ã€‚ sys_sigreturnæ²¡æœ‰è¿”å›å€¼ï¼Œåœ¨æ‰§è¡Œå®Œåä¸åº”å°†æ‰§è¡Œç»“æœå†™å…¥a0å¯„å­˜å™¨ã€‚\nç”±äºæ‰§è¡Œä¿¡å·å¤„ç†å‡½æ•°æ—¶ä¸æ‰§è¡Œå…¶ä»–ç”¨æˆ·å‡½æ•°æ²¡æœ‰åŒºåˆ«ï¼Œlinuxçš„ä¿¡å·è®¾è®¡è‡ªç„¶æ”¯æŒä¿¡å·å¤„ç†çš„åµŒå¥—ï¼Œ åªè¦æ­£ç¡®å®ç°äº†è¿™å‡ ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œæ— éœ€åœ¨å†…æ ¸å†…ä¿å­˜é¢å¤–ä¿¡æ¯å°±å¯ä»¥æ”¯æŒä¿¡å·çš„åµŒå¥—è°ƒç”¨ã€‚ ä¸€èˆ¬ä¿¡å·çš„äº§ç”Ÿæ˜¯é€šè¿‡sys_killç­‰ç³»ç»Ÿè°ƒç”¨äº§ç”Ÿçš„ï¼Œé™¤æ­¤ä¹‹å¤–è¿›ç¨‹é€€å‡ºæ—¶ä¹Ÿä¼šäº§ç”Ÿä¿¡å·ã€‚ ä¿¡å·å¤„ç†çš„æ—¶æœºæ˜¯ä¸ç¡®å®šçš„ã€‚ç°åœ¨å†…æ ¸ä¸­ä¼šåœ¨æ¯æ¬¡è¿”å›ç”¨æˆ·æ€ä¹‹å‰æ£€æŸ¥æœ‰æ— éœ€è¦å¤„ç†çš„ä¿¡å·ã€‚\nä¸å…¶ä»–ç³»ç»Ÿè°ƒç”¨çš„äº¤äº’ sys_wait4 ã€sys_readã€sys_futexç­‰å…·æœ‰é˜»å¡ç­‰å¾…è¡Œä¸ºçš„ç³»ç»Ÿè°ƒç”¨å¯ä»¥è¢«ä¿¡å·ä¸­æ–­ï¼Œ å¦‚æœåœ¨é˜»å¡è¿‡ç¨‹ä¸­æœ‰åˆ°æ¥çš„ä¿¡å·åº”è¯¥åœæ­¢ç­‰å¾…ï¼Œè¿”å›è¢«ä¸­æ–­çš„é”™è¯¯ç ã€‚ fork å‡ºæ¥çš„å­è¿›ç¨‹åº”è¯¥ç»§æ‰¿çˆ¶è¿›ç¨‹çš„æ³¨å†Œçš„ä¿¡å·å¤„ç†ç¨‹åºï¼Œå’Œä¿¡å·æ©ç ã€‚ exec åç¨‹åºåº”è¯¥æ¸…ç©ºä¿¡å·å¤„ç†ç¨‹åºä½†æ˜¯ä¿ç•™ä¿¡å·æ©ç ã€‚\n","date":"2023-08-01","permalink":"https://bitethedisk.github.io/post/signal/","tags":["å…¨å›½èµ›ç¬¬ä¸€é˜¶æ®µ"],"title":"[å…¨å›½èµ›I] ä¿¡å·å¤„ç†"},{"content":"ç”±äºå¤§éƒ¨åˆ†æµ‹è¯•éœ€è¦ä½¿ç”¨ busyboxï¼Œä¸ºäº†é¿å…å¤šæ¬¡è§£æ elfã€ä»é›¶åˆ›å»ºåœ°å€ç©ºé—´ç­‰é—®é¢˜ï¼Œæˆ‘ä»¬é‡‡ç”¨äº†ç±»ä¼¼äºåŠ è½½initprocçš„æ–¹æ³•ã€‚\nå…·ä½“è€Œè¨€ï¼Œæˆ‘ä»¬å°† busybox é¢„åŠ è½½åˆ°å†…æ ¸ä¸­ï¼Œå¹¶ä¿å­˜ load_elf è·å–çš„ä¿¡æ¯ã€‚æ¯æ¬¡æ‰§è¡Œbusyboxæ—¶ï¼Œæˆ‘ä»¬ç›´æ¥ä½¿ç”¨ä¿å­˜çš„ load_elf ä¿¡æ¯ï¼Œå¹¶é€šè¿‡å†™æ—¶æ‹·è´æ¥åˆ›å»ºæ‰€éœ€çš„ busybox è¿›ç¨‹çš„åœ°å€ç©ºé—´ï¼Œæ›´å¿«é€Ÿåœ°åˆ›å»º busybox è¿›ç¨‹ä»è€Œå®ç°æ›´é«˜æ•ˆçš„æµ‹è¯•ã€‚\n// kernel/src/task/initproc/mod.rs pub static ref BUSYBOX: RwLock\u0026lt;Busybox\u0026gt; = RwLock::new({ extern \u0026quot;C\u0026quot; { fn busybox_entry(); fn busybox_tail(); } let entry = busybox_entry as usize; let tail = busybox_tail as usize; let siz = tail - entry; let busybox = unsafe { core::slice::from_raw_parts(entry as *const u8, siz) }; let path = AbsolutePath::from_str(\u0026quot;/busybox0\u0026quot;); let inode = fs::open(path, OpenFlags::O_CREATE, CreateMode::empty()).expect(\u0026quot;busybox0 create failed\u0026quot;); inode.write_all(\u0026amp;busybox.to_owned()); let bb = Arc::new(TaskControlBlock::new(inode.clone())); inode.delete(); Busybox { inner: bb, } }); pub static mut ONCE_BB_ENTRY: usize = 0; pub static mut ONCE_BB_AUX: Vec\u0026lt;AuxEntry\u0026gt; = Vec::new(); pub struct Busybox { inner: Arc\u0026lt;TaskControlBlock\u0026gt;, } impl Busybox { pub fn elf_entry_point(\u0026amp;self) -\u0026gt; usize { unsafe { ONCE_BB_ENTRY } } pub fn aux(\u0026amp;self) -\u0026gt; Vec\u0026lt;AuxEntry\u0026gt; { unsafe { ONCE_BB_AUX.clone() } } pub fn memory_set(\u0026amp;self) -\u0026gt; MemorySet { let mut write = self.inner.memory_set.write(); MemorySet::from_copy_on_write(\u0026amp;mut write) } } ","date":"2023-08-01","permalink":"https://bitethedisk.github.io/post/busybox-pre-init/","tags":["å…¨å›½èµ›ç¬¬ä¸€é˜¶æ®µ"],"title":"[å…¨å›½èµ›I] busybox é¢„åŠ è½½"},{"content":"åœ¨æˆ‘ä»¬çš„å†…æ ¸ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ TASKMANAGER ç®¡ç†åˆ†åˆ«å¤„äºå°±ç»ªæ€ï¼Œé˜»å¡æ€çš„è¿›ç¨‹ï¼ŒåŒ…æ‹¬å› ä¸ºè°ƒç”¨ nanosleep è€Œä¼‘çœ çš„è¿›ç¨‹ã€‚\n// kernel/src/task/manager.rs // è´Ÿè´£ç®¡ç†å¾…è°ƒåº¦çš„è¿›ç¨‹å¯¹è±¡ pub struct TaskManager { ready_queue: VecDeque\u0026lt;Arc\u0026lt;TaskControlBlock\u0026gt;\u0026gt;, waiting_queue: VecDeque\u0026lt;Arc\u0026lt;TaskControlBlock\u0026gt;\u0026gt;, hq: BinaryHeap\u0026lt;HangingTask\u0026gt;, } // ç”¨äºç®¡ç† sleep è¿›ç¨‹ pub struct HangingTask { wake_up_time: usize, // ns inner: Arc\u0026lt;TaskControlBlock\u0026gt;, } // ç”¨äºå¤„ç†å­çº¿ç¨‹çš„èµ„æºå›æ”¶ pub struct ChildrenThreadMonitor { cancelled_child_threads: Vec\u0026lt;Arc\u0026lt;TaskControlBlock\u0026gt;\u0026gt;, } // ç»´æŠ¤å†…æ ¸ä¸­ pid åˆ° TCB çš„æ˜ å°„ pub static ref PID2TCB: Mutex\u0026lt;BTreeMap\u0026lt;usize, Arc\u0026lt;TaskControlBlock\u0026gt;\u0026gt;\u0026gt; = Mutex::new(BTreeMap::new()); // å­çº¿ç¨‹å›æ”¶ç®¡ç†å™¨ pub static CHILDREN_THREAD_MONITOR: Mutex\u0026lt;ChildrenThreadMonitor\u0026gt; = Mutex::new(ChildrenThreadMonitor::new()); // kernel/src/task/processor/processor.rs /// [`Processor`] æ˜¯æè¿° CPUæ‰§è¡ŒçŠ¶æ€ çš„æ•°æ®ç»“æ„ã€‚ /// åœ¨å•æ ¸ç¯å¢ƒä¸‹ï¼Œæˆ‘ä»¬ä»…åˆ›å»ºå•ä¸ª Processor çš„å…¨å±€å®ä¾‹ PROCESSOR pub static mut PROCESSOR: SyncRefCell\u0026lt;Processor\u0026gt; = SyncRefCell::new(Processor::new()); /// æ¯ä¸ªæ ¸ä¸Šçš„å¤„ç†å™¨ï¼Œè´Ÿè´£è¿è¡Œä¸€ä¸ªè¿›ç¨‹ pub struct Processor { /// å½“å‰å¤„ç†å™¨ä¸Šæ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡ current: Option\u0026lt;Arc\u0026lt;TaskControlBlock\u0026gt;\u0026gt;, /// å½“å‰å¤„ç†å™¨ä¸Šçš„ idle æ§åˆ¶æµçš„ä»»åŠ¡ä¸Šä¸‹æ–‡ idle_task_cx: TaskContext, } run_tasks åˆ†åˆ«å°è¯•ä» hang_task, ready_task é˜Ÿåˆ—ä¸­è·å–è¿›ç¨‹è°ƒåº¦ã€‚\n// kernel/src/task/processor/schedule.rs /// è¿›å…¥ idle æ§åˆ¶æµï¼Œå®ƒè¿è¡Œåœ¨è¿™ä¸ª CPU æ ¸çš„å¯åŠ¨æ ˆä¸Šï¼Œ /// åŠŸèƒ½æ˜¯å¾ªç¯è°ƒç”¨ fetch_task ç›´åˆ°é¡ºåˆ©ä»ä»»åŠ¡ç®¡ç†å™¨ä¸­å–å‡ºä¸€ä¸ªä»»åŠ¡ï¼Œéšåä¾¿å‡†å¤‡é€šè¿‡ä»»åŠ¡åˆ‡æ¢çš„æ–¹å¼æ¥æ‰§è¡Œ pub fn run_tasks() { let bb = BUSYBOX.read(); // lazy static busybox drop(bb); loop { let processor = acquire_processor(); recycle_child_threads_res(); if let Some(hanging_task) = check_hanging() { run_task(hanging_task, processor); } else if let Some(interupt_task) = check_futex_interupt_or_expire() { unblock_task(interupt_task); } else if let Some(task) = fetch_task() { run_task(task, processor); } } } å€¼å¾—ä¸€æçš„æ˜¯ï¼Œæˆ‘ä»¬åœ¨è¿›ç¨‹è°ƒåº¦æ—¶è¿˜éœ€è¦æ£€æµ‹ block_task é˜Ÿåˆ—ä¸­ï¼Œ å› ä¸ºåœ¨ç³»ç»Ÿè°ƒç”¨è¿‡ç¨‹ä¸­è¢«ä¿¡å·æ‰“æ–­çš„ task æ˜¯å¦æœ‰å¤„ç†å®Œä¿¡å·ï¼Œæˆ–è€… futex_wait æ—¶ç»™å‡ºçš„ timeout æ˜¯å¦å·²è¶…æ—¶ä»¥å”¤é†’è¯¥è¿›ç¨‹å¹¶åŠ å…¥åˆ° ready_task ä¸­ã€‚\n// kernel/src/task/manager.rs pub fn check_futex_interupt_or_expire(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Arc\u0026lt;TaskControlBlock\u0026gt;\u0026gt; { for tcb in self.waiting_queue.iter() { let lock = tcb.inner_ref(); // è¢«ä¿¡å·æ‰“æ–­çš„ task æ˜¯å¦æœ‰å¤„ç†å®Œä¿¡å· if !lock.pending_signals.difference(lock.sigmask).is_empty() { return Some(tcb.clone()); } } let mut global_futex_que = FUTEX_QUEUE.write(); for (_, futex_queue) in global_futex_que.iter_mut() { // timeout æ˜¯å¦å·²è¶…æ—¶ if let Some(task) = futex_queue.pop_expire_waiter() { return Some(task.clone()); } } None } ","date":"2023-08-01","permalink":"https://bitethedisk.github.io/post/scheduling/","tags":["è¿›ç¨‹","çº¿ç¨‹","å…¨å›½èµ›ç¬¬ä¸€é˜¶æ®µ"],"title":"[å…¨å›½èµ›I] è¿›ç¨‹/çº¿ç¨‹è°ƒåº¦"},{"content":"TCB ä¸ fork çš„æ›´æ”¹ ç›¸è¾ƒäºåˆèµ›ï¼Œå®Œå–„äº† clone ç³»ç»Ÿè°ƒç”¨ã€‚åˆèµ›æ—¶ç”±äºè¦æ±‚æµ‹è¯•æ ·ä¾‹è¦æ±‚æ¯”è¾ƒä½ï¼Œåœ¨å®ç° clone ç³»ç»Ÿè°ƒç”¨æ—¶å¹¶æœªå®Œå…¨åˆ©ç”¨ç”¨æˆ·ä¼ é€’çš„å‚æ•°ã€‚æˆ‘ä»¬æ ¹æ® Linux manual page ä¸­çš„è¦æ±‚ï¼Œå®Œå–„äº†å†…æ ¸çš„ fork ä»¥åŠ TaskControlBlock ç»“æ„ã€‚\n// kernel/task/task.rs pub struct TaskControlBlock { ... pub sigactions: Arc\u0026lt;RwLock\u0026lt;[SigAction; MAX_SIGNUM as usize]\u0026gt;\u0026gt;, pub memory_set: Arc\u0026lt;RwLock\u0026lt;MemorySet\u0026gt;\u0026gt;, pub fd_table: Arc\u0026lt;RwLock\u0026lt;FDTable\u0026gt;\u0026gt;, pub robust_list: Arc\u0026lt;RwLock\u0026lt;RobustList\u0026gt;\u0026gt;, pub rlimit_nofile: Arc\u0026lt;RwLock\u0026lt;RLimit\u0026gt;\u0026gt;, inner: RwLock\u0026lt;TaskControlBlockInner\u0026gt;, } pub struct TaskControlBlockInner { ... pub pending_signals: SigSet, pub sigmask: SigMask, pub interval_timer: Option\u0026lt;IntervalTimer\u0026gt;, pub utime: TimeVal, pub stime: TimeVal, pub last_enter_umode_time: TimeVal, pub last_enter_smode_time: TimeVal, pub clear_child_tid: usize, /* CLONE_CHILD_CLEARTID */ } ç›¸è¾ƒäºåˆèµ›ï¼Œæˆ‘ä»¬ä¸º TCB åŠ å…¥äº†æœ‰å…³ä¿¡å·ã€æ—¶é—´ã€èµ„æºç­‰ç»“æ„ã€‚å¹¶æ ¹æ® sys_clone ä¼ é€’çš„å‚æ•°ï¼Œæ­£ç¡®åœ°å®ç° forkï¼Œæ¯”å¦‚ä»¥ä¸‹ä»£ç æ®µï¼š\n// kernel/src/task/task.rs(fn fork) // æ‹·è´ç”¨æˆ·åœ°å€ç©ºé—´ let memory_set = if flags.contains(CloneFlags::VM) { self.memory_set.clone() } else { Arc::new(RwLock::new(MemorySet::from_copy_on_write( \u0026amp;mut self.memory_set.write(), ))) }; if flags.contains(CloneFlags::THREAD) { memory_set.write().map_thread_trap_context(private_tid); } // kernel/syscall/impls/process.rs (sys_do_fork) if flags.contains(CloneFlags::PARENT_SETTID) { *translated_mut(current_user_token(), ptid as *mut u32) = new_pid as u32; } if flags.contains(CloneFlags::CHILD_SETTID) { *translated_mut(child_token, ctid as *mut u32) = new_pid as u32; } if flags.contains(CloneFlags::CHILD_CLEARTID) { new_task.inner_mut().clear_child_tid = ctid; } if flags.contains(CloneFlags::SETTLS) { let trap_cx = new_task.inner_mut().trap_context(); trap_cx.set_tp(tls); } çº¿ç¨‹çš„å¼•å…¥ åœ¨ fork è¿‡ç¨‹ä¸­ï¼Œå½“ CloneFlags ä¸­å­˜åœ¨ CLONE_THREAD ä½æ—¶ï¼Œæ­£åœ¨åˆ›å»ºçš„è¿›ç¨‹å½“å‰è¿›ç¨‹çš„ä¸ºå­çº¿ç¨‹\nPid åˆ†é…å™¨çš„æ›´æ”¹\nç”±äºæˆ‘ä»¬çš„å†…æ ¸åœ¨å®ç°çº¿ç¨‹æ—¶ï¼Œä¸ºäº†æ›´æ–¹ä¾¿åœ°ä¸ºå­çº¿ç¨‹åˆ†é… TrapContext Frame èµ„æºï¼Œæˆ‘ä»¬è§„å®šå­çº¿ç¨‹çš„ tid (pid) ä¸åº”è¯¥ä¸å°äºè¿›ç¨‹ï¼ˆä¸»çº¿ç¨‹ï¼‰çš„ tid (pid) ï¼Œæ•…ç§»é™¤äº†è¿›ç¨‹ pid çš„å›æ”¶æ“ä½œã€‚\nå­è¿›ç¨‹ä¸å­çº¿ç¨‹çš„åŒºåˆ†\nç›®å‰æˆ‘ä»¬å°†å­çº¿ç¨‹ä¸å­è¿›ç¨‹å‡ä¿å­˜åœ¨ TCB çš„ children å­—æ®µï¼Œåœ¨é‡åˆ°è¿›ç¨‹é€€å‡ºç­‰é—®é¢˜æ—¶ä¼šåˆ¤æ–­ child æ˜¯å­è¿›ç¨‹è¿˜æ˜¯å­çº¿ç¨‹ã€‚\nç›®å‰é€šè¿‡ tgid ä¸ pid æ¥åŒºåˆ† TCB æ˜¯çˆ¶è¿›ç¨‹çš„å­è¿›ç¨‹è¿˜æ˜¯å­çº¿ç¨‹\n// kernel/src/task/task.rs(fn fork) let pid_handle = pid_alloc(); let tgid = if flags.contains(CloneFlags::THREAD) { self.pid.0 } else { pid_handle.0 }; å¦‚æœ tgid ä¸ pid å€¼ç›¸åŒï¼Œåˆ™è¯¥ TCB ä¸ºè¿›ç¨‹ï¼Œå¦åˆ™ä¸ºçº¿ç¨‹\nä¸ºçº¿ç¨‹åˆ†é…èµ„æº\nçº¿ç¨‹é™¤äº†å…±äº«ä¸»çº¿ç¨‹ï¼ˆè¿›ç¨‹ï¼‰çš„ memory_set, fd_table, sigaction ç­‰èµ„æºï¼Œè¿˜éœ€è¦ä¸€äº›ç‹¬ç«‹çš„èµ„æºå¦‚ID, å†…æ ¸åœ°å€ç©ºé—´çš„KernelStackï¼Œä»¥åŠä¸»çº¿ç¨‹ä¸­ç‹¬ç«‹åˆ†é…çš„ TrapContext Frame:\n// kernel/syscall/impls/process.rs (sys_do_fork) if flags.contains(CloneFlags::THREAD) { memory_set.write().map_thread_trap_context(private_tid); } // kernel/src/task/ttask.rs pub fn trap_context_position(tid: usize) -\u0026gt; VirtAddr { VirtAddr::from(TRAP_CONTEXT - tid * PAGE_SIZE) } å…¶ä¸­ï¼Œprivate_tid ä¸ºtgid(ä¸»çº¿ç¨‹/çˆ¶è¿›ç¨‹)ä¸pid(å­çº¿ç¨‹tid)çš„å·®å€¼\nè¿›ç¨‹/çº¿ç¨‹çš„é€€å‡º å½“å‰è¿›ç¨‹ç»“æŸçš„æ–¹å¼åŒ…æ‹¬ï¼š\nè¿›ç¨‹è¿è¡Œå®Œä»£ç æ®µï¼Œéæ³•è®¿é—®åˆ° .rodata å¼•å‘ trapï¼Œåœ¨ trap å¤„ç†ä¸­å›æ”¶è¿›ç¨‹å¯¹è±¡ è¿›ç¨‹è°ƒç”¨ exit ç³»ç»Ÿè°ƒç”¨ è¿›ç¨‹æ”¶åˆ° kill ç›¸å…³çš„ä¿¡å·ï¼Œåœ¨ä¿¡å·å¤„ç†æ—¶é€€å‡º å…³äºè¿›ç¨‹/çº¿ç¨‹çš„é€€å‡ºæ—¶éœ€è¦åšçš„å·¥ä½œåŒ…æ‹¬ï¼š\nå®Œæˆè¿›ç¨‹çš„åˆæ­¥å›æ”¶ï¼š å°†è‡ªèº«ä» PID2TCB æ˜ å°„ç®¡ç†å™¨ä¸­ç§»é™¤ æ ‡è®°è‡ªèº«çŠ¶æ€ä¸º Zombieï¼Œè®°å½•é€€å‡ºç  å°†å­è¿›ç¨‹ç§»äº¤ç»™ initproc å¦‚æœè‡ªèº«ä¸ºæŸè¿›ç¨‹çš„å­çº¿ç¨‹ï¼Œè¿˜éœ€è¦æ‰¾åˆ°ä¸»è¿›ç¨‹å¹¶å°†è‡ªèº«ä»ä¸»è¿›ç¨‹ä¸­ç§»é™¤ï¼Œå¹¶å‹å…¥å­çº¿ç¨‹å›æ”¶ç®¡ç†å™¨ CHILDREN_THREAD_MONITOR ä¸­ï¼Œåœ¨ä¸‹ä¸€æ¬¡è¿›ç¨‹è°ƒåº¦æ—¶å›æ”¶å¯å›æ”¶çš„èµ„æº è¿›ç¨‹çš„çˆ¶è¿›ç¨‹ç­‰å¾…å­è¿›ç¨‹é€€å‡ºï¼Œè°ƒç”¨ wait ç³»ç»Ÿè°ƒç”¨ï¼Œå®Œæˆå­è¿›ç¨‹èµ„æºçš„å›æ”¶ï¼šæ‰¾åˆ°å­è¿›ç¨‹ä¸­å¤„äº Zombie æ€çš„è¿›ç¨‹å¹¶ä¸”å¼ºå¼•ç”¨è®¡æ•°ä¸º 1 çš„è¿›ç¨‹ï¼Œç§»é™¤è¯¥è¿›ç¨‹ä»¥å½»åº•å›æ”¶è¯¥è¿›ç¨‹çš„æ‰€æœ‰èµ„æº å­çº¿ç¨‹èµ„æºå›æ”¶\nå­çº¿ç¨‹é€€å‡ºæ—¶ï¼Œå­çº¿ç¨‹ä¼šåŠ å…¥åˆ°å›æ”¶ç®¡ç†å™¨ CHILDREN_THREAD_MONITOR ä¸­ï¼Œå¹¶åœ¨ä¸‹ä¸€æ¬¡è¿›ç¨‹è°ƒåº¦æ—¶å›æ”¶å¯å›æ”¶çš„èµ„æºã€‚\n// kernel/src/task/mod.rs (fn exit_current_and_run_next) if is_child_thread { let parent = inner.parent.as_ref().unwrap().upgrade().unwrap(); let mut parent_inner = parent.inner_mut(); let children_iter = parent_inner.children.iter(); let (idx, _) = children_iter .enumerate() .find(|(_, t)| t.pid() == pid) .unwrap(); parent_inner.children.remove(idx); drop(parent_inner); drop(parent); drop(inner); assert!(Arc::strong_count(\u0026amp;task) == 1); take_cancelled_chiled_thread(task); schedule(\u0026amp;mut TaskContext::empty() as *mut _); unreachable!() } è¿™ä¸ªè¿‡ç¨‹æœ¬èº«å…¶å®å¯ä»¥ä¸ç”¨åšï¼Œè€Œæ˜¯ç­‰ä¸»çº¿ç¨‹è¿›è¡Œ wait ç³»ç»Ÿè°ƒç”¨æ—¶å½»åº•å›æ”¶ã€‚ ä½†ç”±äºæµ‹è¯•è¿‡ç¨‹ä¸­ï¼Œè¿›ç¨‹ä¼šåˆ›å»ºæˆåƒä¸Šä¸‡ä¸ªå­çº¿ç¨‹ï¼Œå¦‚æœè¿™äº›çº¿ç¨‹èµ„æºæ²¡æœ‰åŠæ—¶å›æ”¶ï¼Œå¦‚ TrapContext, KenerlStack ç­‰èµ„æºï¼Œä¼šæµªè´¹è®¸å¤šå†…å­˜èµ„æºã€‚\nå…¶å® take_cancelled_chiled_thread(task)è¿™æ®µä»£ç æœ¬èº«ï¼Œä»¥åŠ CHILDREN_THREAD_MONITORå˜é‡ï¼Œä¹Ÿå°±æ˜¯è¯´è¿™æ®µä»£ç æœ¬èº«å…¶å®å¯ä»¥ç›´æ¥æ”¹ä¸º drop(task)ï¼Œ å› ä¸ºæ­¤æ—¶ task å¼ºå¼•ç”¨è®¡æ•°ä¸€å®šä¸º 1ï¼Œtask ä¸­å¯ä»¥é‡Šæ”¾çš„èµ„æºéƒ½å¯ä»¥åœ¨, schedule ä¹‹å‰é‡Šæ”¾æ‰ä½†æ˜¯ task åœ¨æ‰§è¡Œ exit_current_and_run_nextæ—¶æœ¬èº«å‡ºäºå†…æ ¸æ€ï¼Œæ­¤æ—¶å›æ”¶ task çš„ KerenlStack æ—¢ä¸ç¬¦åˆé€»è¾‘ï¼Œåˆæœ‰å¯èƒ½äº§ç”Ÿä¸€äº›éšæ‚£ï¼Œæ•…é€‰æ‹©ä½¿ç”¨ CHILDREN_THREAD_MONITOR åœ¨è°ƒåº¦æ—¶é‡Šæ”¾é€€å‡ºçš„çº¿ç¨‹ã€‚\n","date":"2023-08-01","permalink":"https://bitethedisk.github.io/post/process-thread/","tags":["è¿›ç¨‹","çº¿ç¨‹","å…¨å›½èµ›ç¬¬ä¸€é˜¶æ®µ"],"title":"[å…¨å›½èµ›I] è¿›ç¨‹ç®¡ç†-è¿›ç¨‹ä¸çº¿ç¨‹"},{"content":"ä¸€å¼€å§‹\n","date":"2023-07-12","permalink":"https://bitethedisk.github.io/post/opensbi-getchar/","tags":["å…¨å›½èµ›ç¬¬ä¸€é˜¶æ®µ"],"title":"é€‚é… OpenSBI"},{"content":"Rust å’Œ C äº¤äº’çš„æ—¶å€™éœ€è¦æ³¨æ„ Rust çš„å †ï¼Œå½“ä» Rust ç¨‹åº fork å‡ºä¸€ä¸ªè¿›ç¨‹ æ¥æ‰§è¡Œ C ç¨‹åºçš„æ—¶å€™ï¼ŒC æ˜¯ä¸èƒ½è¯†åˆ« Rust çš„å †çš„(åŒ…æ‹¬å…¶å †ç®¡ç†å™¨è¿™äº›)ï¼Œæ‰€ä»¥å½“ ä½¿ç”¨ C ç¨‹åºå»è®¿é—® fork åçš„ Rust å †ä¸Šçš„å¯¹è±¡ï¼Œæˆ–è€…ä¼ é€’ç›¸å…³å †ä¸Šå¯¹è±¡çš„æ—¶å€™å¯èƒ½ ä¼šäº§ç”Ÿè‡´å‘½é—®é¢˜(å¦‚éæ³•å†…å­˜è®¿é—®\u0026mdash;è®¿é—®è¶Šç•Œ)\n","date":"2023-07-07","permalink":"https://bitethedisk.github.io/post/rust-heap-and-c/","tags":null,"title":"Rust Heap and C"},{"content":"éšç€å¼€å‘çš„è¿›è¡Œï¼Œæˆ‘ä»¬éœ€è¦çš„é€‚é…å’Œå°è£…çš„æ•°æ®ç»“æ„è¶Šæ¥è¶Šå¤šï¼Œå…¶ä¸­å¤§éƒ¨åˆ†ä¸æˆ‘ä»¬çš„å†…æ ¸æœ¬ä½“å…³ç³»å¹¶æ²¡æœ‰é‚£ä¹ˆç´§å¯†ï¼Œ æ‰€ä»¥æˆ‘ä»¬å°†è¿™éƒ¨åˆ†ç»“æ„ï¼Œå¦‚ç”¨äºçš„å¼•å¯¼ç¨‹åºã€FAT32ã€Linux ç›¸å…³æ•°æ®ç»“æ„æ”¾åœ¨äº†é¡¹ç›®æ ¹ç›®å½•ä¸­çš„ crates é‡Œ\nRust æœ¬èº«æ˜¯æ”¯æŒå¤šä¸ª crates æ„æˆçš„ä¸€ä¸ª workspaceï¼Œè¿™äº› crates ç›´æ¥å¯ä»¥ç›¸äº’å¼•ç”¨ï¼Œä½†æ˜¯ç”±äºæˆ‘ä»¬ä½¿ç”¨ äº† .cargo/config.toml æ¥é…ç½® rustcï¼Œæ‰€ä»¥ workspace å¹¶ä¸èƒ½ä¸ºæˆ‘ä»¬æ‰€æœ‰ (å› ä¸ºç›®å‰ workspace ä¸æ”¯æŒåœ¨ workspace ä¸­è¯»å– .cargo/config.toml)\nä½¿ç”¨ Git Submodule ç®¡ç†æµ‹ä¾‹ ä¸åŒºåŸŸèµ›ä¸åŒï¼Œå…¨å›½èµ›çš„æµ‹ä¾‹æ•°ç›®è¾ƒå¤šï¼Œå¦‚æœä¸€æ—¦å‘ç”Ÿæ›´æ–°æ„å»ºèµ·æ¥ä¹Ÿç›¸å¯¹éº»çƒ¦\nåŸºäº Git Submodule æˆ‘ä»¬å¯ä»¥æ–¹ä¾¿éš”ç¦»å½“å‰ Git ä»“åº“ï¼Œåšåˆ°ä¾èµ–çš„éš”ç¦»ä¸åŒæ­¥\nå°±å½“å‰çš„å®é™…ç¯å¢ƒæ¥è¯´:\ngit submodule add https://github.com/oscomp/testsuits-for-oskernel.git testsuits ä¸Šé¢çš„ä½œç”¨æ˜¯å°† testsuits-for-oskernel.git clone åˆ°æœ¬åœ°çš„ testsuits æ–‡ä»¶å¤¹ä¸­ï¼Œåè€…ä¼šè‡ªåŠ¨åˆ›å»º\nå½“é‡æ–°æ‹‰å–é¡¹ç›®ä»“åº“æ—¶:\ngit submodule init git submodule update å°±å¯ä»¥é‡æ–°æ‹‰å– testsuits ä¸­ï¼Œä»“åº“çš„å†…å®¹äº†\né¡¹ç›®ç›®å½•æ ‘ . â”œâ”€â”€ Makefile â”œâ”€â”€ README.md â”œâ”€â”€ crates â”‚Â â”œâ”€â”€ fat32/ ---- FAT32 è¯»å†™åº“ â”‚Â â”œâ”€â”€ libd/ ---- libc çš„~~åç»§è€…(åˆ’æ‰)~~ initprocï¼Œå†…æ ¸è‡ªåŠ¨åŠ è½½çš„ç¬¬ä¸€ä¸ªç”¨æˆ·ç¨‹åº â”‚Â â”œâ”€â”€ nix/ ---- Linux ç›¸å…³æ•°æ®ç»“æ„ â”‚Â â””â”€â”€ sync_cell/ ---- å®ç°äº† Sync çš„ï¼Œå…·æœ‰å†…éƒ¨å¯å˜æ€§çš„ RefCell â”œâ”€â”€ docs/ â”œâ”€â”€ kernel/ â”‚Â â”œâ”€â”€ Makefile â”‚Â â”œâ”€â”€ build.rs ---- ç”¨äºç›‘æ§ç›¸å…³æ–‡ä»¶ï¼Œå¦‚ `crates/libd/bin/initproc.rs`ï¼Œå‘ç”Ÿå˜åŒ–æ—¶é‡æ–°ç¼–è¯‘ â”‚Â â”œâ”€â”€ cargo â”‚Â â”‚Â â””â”€â”€ config.toml â”‚Â â”œâ”€â”€ linkerld â”‚Â â”‚Â â””â”€â”€ linker.ld â”‚Â â”œâ”€â”€ src â”‚Â â”‚Â â”œâ”€â”€ boards â”‚Â â”‚Â â”‚Â â””â”€â”€ qemu.rs ---- å¹³å°ç›¸å…³å‚æ•° â”‚Â â”‚Â â”œâ”€â”€ console.rs â”‚Â â”‚Â â”œâ”€â”€ consts.rs â”‚Â â”‚Â â”œâ”€â”€ drivers â”‚Â â”‚Â â”œâ”€â”€ entry.S â”‚Â â”‚Â â”œâ”€â”€ error.rs â”‚Â â”‚Â â”œâ”€â”€ fs/ â”‚Â â”‚Â â”œâ”€â”€ logging.rs â”‚Â â”‚Â â”œâ”€â”€ macros â”‚Â â”‚Â â”‚Â â”œâ”€â”€ hsm.rs â”‚Â â”‚Â â”‚Â â”œâ”€â”€ mod.rs â”‚Â â”‚Â â”‚Â â”œâ”€â”€ on_boot.rs â”‚Â â”‚Â â”‚Â â””â”€â”€ profile.rs ---- ç”¨äºæ‰“å°æŸæ®µä»£ç è¿è¡Œæ—¶é—´çš„å® â”‚Â â”‚Â â”œâ”€â”€ main.rs â”‚Â â”‚Â â”œâ”€â”€ mm â”‚Â â”‚Â â”œâ”€â”€ sbi.rs â”‚Â â”‚Â â”œâ”€â”€ syscall/ â”‚Â â”‚Â â”œâ”€â”€ task/ â”‚Â â”‚Â â”œâ”€â”€ timer.rs â”‚Â â”‚Â â””â”€â”€ trap/ â”‚Â â”œâ”€â”€ target/ ---- æ„å»ºäº§ç‰© â”‚Â â””â”€â”€ vendor/ ---- æ‰€æœ‰ç¬¬ä¸‰æ–¹ä¾èµ–çš„æœ¬åœ°å½’æ¡£ â”œâ”€â”€ testsuits/ ---- é€šè¿‡ Git Submodule å†…è”çš„å®˜æ–¹æµ‹ä¾‹ â””â”€â”€ workspace ---- ç”¨äºä¸­é—´è¿‡ç¨‹æ„å»ºå†…æ ¸è¿è¡Œæ‰€éœ€æµ‹ä¾‹ 1187 directories, 9162 files ","date":"2023-06-30","permalink":"https://bitethedisk.github.io/post/project-structure/","tags":["å…¨å›½èµ›ç¬¬ä¸€é˜¶æ®µ"],"title":"[å…¨å›½èµ›I] é¡¹ç›®ç»“æ„(rust-workspaceä¸èƒ½ä½¿ç”¨)"},{"content":"é¡¹ç›®æä¾›äº†ä¸€ç³»åˆ—çš„ Makefile æ¥ç®€åŒ–å¼€å‘æµç¨‹.\nä¸€èˆ¬åªä¼šç”¨åˆ°é¡¹ç›®æ ¹ç›®å½•ä¸­çš„ Makefile:\nBOOTLOADER_ELF = ./kernel/bootloader/rustsbi-qemu KERNEL_ELF = ./kernel/target/riscv64gc-unknown-none-elf/release/kernel sbi-qemu: @cp $(BOOTLOADER_ELF) sbi-qemu kernel-qemu: @mv kernel/cargo kernel/.cargo @cd kernel/ \u0026amp;\u0026amp; make kernel @cp $(KERNEL_ELF) kernel-qemu all: sbi-qemu kernel-qemu clean: @rm -f kernel-qemu @rm -f sbi-qemu @rm -rf build/ @rm -rf temp/ @cd kernel/ \u0026amp;\u0026amp; cargo clean @cd workspace/ \u0026amp;\u0026amp; make clean @cd fat32/ \u0026amp;\u0026amp; cargo clean @cd misc/ \u0026amp;\u0026amp; make clean fat32img: @cd kernel/ \u0026amp;\u0026amp; make fat32img run: @cd kernel/ \u0026amp;\u0026amp; make run debug-server: @cd kernel/ \u0026amp;\u0026amp; make debug-server debug: @cd kernel/ \u0026amp;\u0026amp; make debug è¿™é‡Œåªéœ€å…³æ³¨ä»¥ä¸‹å‡ ç‚¹:\nrun: æ„å»ºå†…æ ¸å¹¶è¿è¡Œï¼Œå†…æ ¸æ˜¯ä»¥ release æ–¹å¼æ„å»ºçš„ debug-server: ä»¥ debug æ–¹å¼æ„å»ºå†…æ ¸å¹¶è¿è¡Œ gdb debug server debug: é“¾æ¥ä¸Šé¢è¿è¡Œçš„ debug server å¼€å§‹è°ƒè¯• ","date":"2023-06-30","permalink":"https://bitethedisk.github.io/post/about-makefile/","tags":["Makefile","Debug","åŒºåŸŸèµ›"],"title":"[åŒºåŸŸèµ›] æœ‰å…³ BTD çš„ Makefile"},{"content":"åœ¨ BTD çš„å¼€å‘ä¸­ç»å¸¸ä¼šé‡åˆ° debug çš„éœ€æ±‚ï¼ŒBTD æä¾›äº†ä¸€ä¸ªæ–¹ä¾¿çš„è°ƒè¯•æµç¨‹ï¼Œåªéœ€å¯åŠ¨ä¸¤ä¸ª shell å³å¯ å¼€å§‹è°ƒè¯•\nä¸‹é¢å°†æ¼”ç¤ºä¸€æ¬¡å…·ä½“çš„è°ƒè¯•æµç¨‹\nå¯åŠ¨ä¸¤ä¸ª shellï¼Œåœ¨é¡¹ç›®æ ¹ç›®å½•ä¸‹åˆ†åˆ«è¿è¡Œ make debug-server å’Œ make debugï¼Œ ä¹‹ååªéœ€è¦åœ¨è¿è¡Œ make debug çš„ shell ä¸­æ‰§è¡Œæ¥ä¸‹æ¥çš„å‘½ä»¤å³å¯ # ä»å½“å‰ pc å¼€å§‹æ˜¾ç¤º 11 æ¡æŒ‡ä»¤ï¼Œ11 æ¡æ˜¯ä¸å‘ç”ŸæŠ˜å çš„æé™ï¼ˆä¹Ÿå¯èƒ½åªæ˜¯æˆ‘è¿™æ˜¯è¿™æ ·ï¼‰ (gdb) x/11i $pc (gdb) b *0x80000000 # åœ¨å†…æ ¸ç¬¬ä¸€æ¡æŒ‡ä»¤å¤„æ‰“ä¸ªæ–­ç‚¹ (gdb) c # continue æ‰§è¡Œåˆ°æ–­ç‚¹å¤„ (gdb) si # si å•æ­¥æ‰§è¡Œ (step inï¼Œä¼šåµŒå…¥å‡½æ•°å…·ä½“æµç¨‹ä¸­) éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨å¤šæ ¸è¿è¡Œæ—¶ï¼Œä»£ç æ‰§è¡Œè¿‡ç¨‹ä¸­ä¼šå‡ºç°ç³»ç»Ÿçº¿ç¨‹çš„åˆ‡æ¢ï¼Œä¾‹å¦‚ä¸‹é¢è¿™æ ·ï¼š\n(gdb) c Continuing. [Switching to Thread 1.2] è¿™æ—¶å€™æˆ‘ä»¬è¦çœ‹å½“å‰çº¿ç¨‹çš„çŠ¶æ€ï¼Œæ ¹æ®å½“å‰çŠ¶æ€è¿›è¡Œè°ƒè¯•ï¼Œè¯¥æ‰“æ–­ç‚¹çš„åœ°æ–¹ä¸è¦å¿˜äº†æ‰“æ–­ç‚¹ï¼Œä¸ç„¶ä¼šè·‘é£\nåƒæ˜¯è¿™æ ·ï¼Œåªèƒ½ç”¨ Ctrl + C æ¥ææ­» (ä¸»è¦æ˜¯æˆ‘ä¹Ÿæ²¡å»æ‰¾å…¶ä»–å¯èƒ½çš„æ–¹æ³• ğŸ˜›):\nçœ‹åˆ°åœ°å€äº†å—ï¼Œç›´æ¥å½’é›¶ï¼Œè€Œä¸”è¿™å—åœ°å€æ˜¯ä¸å¯è®¿é—®çš„ï¼Œåªèƒ½å¡åœ¨è¿™äº†ï¼Œé™¤éæ‰¬äº†å½“å‰çš„ shell é‡æ¥ï¼ˆå¤§æ¦‚\nThread 2 received signal SIGINT, Interrupt. 0x0000000000000000 in ?? () (gdb) x/11i $pc =\u0026gt; 0x0: Cannot access memory at address 0x0 (gdb) ","date":"2023-06-30","permalink":"https://bitethedisk.github.io/post/how-to-debug-the-kernel/","tags":["Debug"],"title":"å¦‚ä½•è°ƒè¯• BTD-OS"},{"content":"å†…æ ¸åœ¨è¿è¡Œçš„æ—¶å€™æ€»æ˜¯ä¼šä¸çŸ¥ä½•æ—¶å¡æ­»ï¼Œåº•å±‚åŸå› æ˜¯æŒç»­è§¦å‘æ—¶é’Ÿä¸­æ–­\n// æ—¶é—´ç‰‡åˆ°äº† Trap::Interrupt(Interrupt::SupervisorTimer) =\u0026gt; { set_next_trigger(); // ä¸»è¦æ˜¯è¿™é‡Œ suspend_current_and_run_next(); } åˆæ­¥è§£å†³ æˆ‘ä»¬å°†è®¾ç½®ä¸‹ä¸€ä¸ªæ—¶é’Ÿä¸­æ–­æ”¾ç½®åœ¨äº† suspend_current_and_run_next ä¹‹å‰ï¼Œå¯¼è‡´å¯èƒ½å› ä¸ºåè€…æ‰§è¡Œ æ—¶é—´è¿‡é•¿è€Œä½¿ç”¨æˆ·æ€ä¸€ç›´å¤„äºæ—¶é’Ÿä¸­æ–­è§¦å‘çŠ¶æ€ï¼Œè‡³äºä¸ºä»€ä¹ˆä¼šåœ¨ RV64 ä¸Šä¸€ç›´è§¦å‘ä¸­æ–­ï¼Œå¯ä»¥å‚é˜… RV çš„ç‰¹æƒçº§æ‰‹å†Œ:\nPlatforms provide a real-time counter, exposed as a memory-mapped machine-mode read-write register, mtime. mtime must increment at constant frequency, and the platform must provide a mechanism for determining the period of an mtime tick. The mtime register will wrap around if the count overflows.\nThe mtime register has a 64-bit precision on all RV32 and RV64 systems. Platforms provide a 64- bit memory-mapped machine-mode timer compare register (mtimecmp). A machine timer interrupt becomes pending whenever mtime contains a value greater than or equal to mtimecmp, treating the values as unsigned integers. The interrupt remains posted until mtimecmp becomes greater than mtime (typically as a result of writing mtimecmp). The interrupt will only be taken if interrupts are enabled and the MTIE bit is set in the mie register.\nç”±äº suspend_current_and_run_next æ‰§è¡Œçš„æ—¶é—´è¶…è¿‡äº†ä¸€ä¸ªæ—¶é—´ç‰‡çš„é•¿åº¦ï¼Œå¯¼è‡´å…¶è¿”å›ç”¨æˆ·æ€è¿›ç¨‹æ—¶ï¼Œ mtime çš„å€¼å·²ç»å¤§äºäº† set_next_trigger è®¾ç½®çš„æ—¶é—´ç‚¹ï¼Œç”±ä¸Šæ–‡å¯å¾—ï¼Œå¦‚æœ mtime å¤§äºç­‰äº mtimecmp(å³ set_next_trigger è®¾ç½®çš„å€¼)ï¼Œå¹¶ä¸” mie ä¸ºä½¿èƒ½çŠ¶æ€ï¼Œé‚£ä¹ˆæ—¶é’Ÿä¸­æ–­ä¼šä¸€ç›´å¤„äºè§¦å‘çŠ¶æ€.\nè€Œæˆ‘ä»¬çš„å†…æ ¸ mie ä¸€ç›´å¤„äºä½¿èƒ½çŠ¶æ€ï¼Œæ‰€ä»¥ S æ€çš„æ—¶é’Ÿä¸­æ–­ä¼šæŒç»­åœ¨ç”¨æˆ·æ€å‘ç”Ÿ(S æ€ä¸­æ–­ä¸ä¼šæ‰“æ–­åŒçº§ä¸ æ›´é«˜ç‰¹æƒçº§ä»£ç çš„æ‰§è¡Œ)ï¼Œå¯¼è‡´ç”¨æˆ·æ€æ¯«æ— è¿›å±•ï¼Œè€Œæˆ‘ä»¬å†…æ ¸çš„å¼•å¯¼ç¨‹åº initproc ä¼šä¸€ç›´ç­‰å¾…å¡æ­»ç”¨æˆ·è¿›ç¨‹ å˜ä¸ºåƒµå°¸æ€ï¼Œæ‰€ä»¥é€ æˆäº†å†…æ ¸æ‰§è¡Œæµçš„å¡æ­».\nè§£å†³åŠæ³•:\nç®€å•è°ƒæ•´ä¸‹ä½ç½®\nTrap::Interrupt(Interrupt::SupervisorTimer) =\u0026gt; { suspend_current_and_run_next(); set_next_trigger(); } ä½†è¿™æ ·çœŸçš„å¯¹å—? ä¸å¯¹ï¼Œå› ä¸ºä¼šå¯¼è‡´ç”¨æˆ·æ€ç¨‹åºå¡æ­»æ•´ä¸ªå†…æ ¸çš„æ‰§è¡Œæµ\nä¸€ä¸ªè‡´å‘½çš„ç¼ºç‚¹æ˜¯ï¼Œç”¨æˆ·æ€çš„ç¨‹åºéœ€è¦ç¬¬ä¸€æ¬¡è¿è¡Œåæ‰èƒ½æ­£ç¡®çš„è·å–æ—¶é’Ÿä¸­æ–­ï¼Œä¸ç„¶åªèƒ½ç­‰è½®å›ä¸€è¾¹åæ‰å¯èƒ½æ­£ç¡®è®©å‡º\nå½“å‰çš„é€»è¾‘æ˜¯:\nRustSBI å®Œæˆåˆå§‹åŒ–åï¼Œåœ¨ meow(æ²¡é”™ï¼Œè¿™æ˜¯æˆ‘ä»¬ Rust ä»£ç çš„ ENTRYPOINT)ï¼Œä¸­åˆæ­¥è®¾å®šä¸€ä¸ªæ—¶é’Ÿä¸­æ–­\n#[cfg(not(feature = \u0026quot;multi_harts\u0026quot;))] #[no_mangle] pub fn meow() -\u0026gt; ! { if hartid!() == 0 { init_bss(); unsafe { set_fs(FS::Dirty) } lang_items::setup(); logging::init(); mm::init(); trap::init(); trap::enable_stimer_interrupt(); trap::set_next_trigger(); fs::init(); task::add_initproc(); task::run_tasks(); } else { loop {} } unreachable!(\u0026quot;main.rs/meow: you should not be here!\u0026quot;); } è¿™æ˜¯ç¬¬ä¸€ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬åŸæœ¬æƒ³çš„æ˜¯ï¼Œè¿™ä¸ªæ—¶é’Ÿä¸­æ–­ä¼šåœ¨ç¬¬ä¸€ç”¨æˆ·æ€ç¨‹åºè¿è¡Œæ—¶å‘ç”Ÿï¼Œä½†æ˜¯æœ‰å¯èƒ½å®ƒåœ¨ fs::init() æˆ–è€… task::add_initproc() ä¸­å·²ç»å‘ç”Ÿäº†ï¼Œè¿™ä¼šå¯¼è‡´ä¸€è¿›å…¥ç”¨æˆ·æ€ç¨‹åºå°±å‘ç”Ÿä¸­æ–­ï¼Œè¿™å’Œæˆ‘ä»¬ é¢„æœŸçš„ä¸ä¸€æ ·.\nè€Œä¸”ï¼Œé™·å…¥ä¸­æ–­åï¼Œé™¤éä½¿å¤±èƒ½ mieï¼Œæˆ–è€…å†æ¬¡ set_next_trigger()(åˆæˆ–è€… mtime å‘ç”Ÿå›ç¯)ï¼Œ å¦åˆ™å°†ä¸€ç›´å¤„äºä¸­æ–­è§¦å‘çš„çŠ¶æ€\nè€Œè¿™ä¹‹ååˆ‡æ¢çš„ç”¨æˆ·è¿›ç¨‹éƒ½ä¼šé‡åˆ°ä¸­æ–­è€Œç›´æ¥è¿”å›ï¼Œç›´åˆ°è¿è¡Œåˆ°ç¬¬ä¸€ä¸ªç”¨æˆ·è¿›ç¨‹(å…¶å®åº”è¯¥æ˜¯å¼•å¯¼ç¨‹åº initproc)ï¼Œ åœ¨ä¸‹é¢ suspend_current_and_run_next çœŸæ­£æ„ä¹‰ä¸Šçš„è¿”å›åï¼Œé‡æ–°è®¾ç½®ä¸‹ä¸€ä¸ªä¸­æ–­æ—¶é—´ç‚¹ï¼Œè¿™æ‰èƒ½è®© OS å†…æ ¸ æ‰€æœ‰çš„ç”¨æˆ·è¿›ç¨‹è¿›å…¥æ­£å¸¸çš„è¿è¡Œæµ.\nTrap::Interrupt(Interrupt::SupervisorTimer) =\u0026gt; { suspend_current_and_run_next(); set_next_trigger(); } è€Œè¿™ç§æ—¶é—´ä¸Šçš„å¼€é”€æ˜¾ç„¶æ˜¯æ²¡å¿…è¦çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬æ ¹æ®æ‰€æœ‰ç”¨æˆ·è¿›ç¨‹éƒ½ä¼šé€šè¿‡ trap_return è¿”å›ç”¨æˆ·æ€è¿™ä¸€ç‚¹ï¼Œ å°† set_next_trigger è®¾ç½®åœ¨äº† trap_return ä¸­ï¼ŒåŒæ—¶åˆ¤æ–­å½“å‰è¿›ç¨‹æ˜¯å¦æ˜¯å› ä¸ºæ—¶é—´ç‰‡è€—å°½è€Œå¯¼è‡´çš„ trap è¿”å›:\nTrap::Interrupt(Interrupt::SupervisorTimer) =\u0026gt; { suspend_current_and_run_next(); } // ... #[no_mangle] pub fn trap_return() -\u0026gt; ! { // ... if is_time_intr_trap() { set_next_trigger(); } // ... } /// æ˜¯å¦æ˜¯ç”±äºæ—¶é—´ç‰‡è€—å°½å¯¼è‡´çš„ trap fn is_time_intr_trap() -\u0026gt; bool { let scause = scause::read(); scause.cause() == Trap::Interrupt(scause::Interrupt::SupervisorTimer) } æœ€ç»ˆç»“æœ æˆ‘ä»¬æ¶ˆé™¤äº†ä¸€ä¸ªä¸¥é‡çš„ bug: å†…æ ¸åœ¨æ‰§è¡Œç”¨æˆ·ç¨‹åºæ—¶éšæœºå¡æ­» åˆ å»äº† meow ä¸­ä¸åˆ©äºç³»ç»Ÿé²æ£’æ€§çš„ä»£ç  ","date":"2023-06-29","permalink":"https://bitethedisk.github.io/post/random-stuck/","tags":["é—®é¢˜ä¸è§£å†³"],"title":"[å·²è§£å†³] å†…æ ¸åœ¨æ‰§è¡Œç”¨æˆ·ç¨‹åºæ—¶éšæœºå¡æ­»"}]